plugins {
	id 'java-library'
	id 'idea' // [核心意图 1] 引入 idea 插件，让我们能通过代码操纵 .iml 项目文件
}

sourceSets.main.resources.srcDirs += [rootProject.file('/assets').path]

dependencies {
	// 引用 libs 目录下所有的 jar 包
	implementation fileTree(dir: 'libs', include: ['*.jar'])
}

// [核心意图 2] 配置 IDEA 模块生成逻辑
idea {
	module {
		// 当 Gradle 生成 .iml 文件时，执行这段逻辑
		iml {
			withXml {
				def node = it.asNode()
				
				// 1. 找到所有的 library 依赖节点
				def orderEntries = node.component.find { it.@name == 'NewModuleRootManager' }.orderEntry
				
				// 2. 遍历 libs 目录下的所有 Jar
				file('libs').eachFile { file ->
					// 只处理普通 Jar，跳过 -javadoc.jar 和 -sources.jar
					if (file.name.endsWith('.jar') && !file.name.endsWith('-javadoc.jar') && !file.name.endsWith('-sources.jar')) {
						
						// 3. 检查是否存在对应的 Javadoc Jar
						def javadocJar = new File(file.parent, file.name.replace('.jar', '-javadoc.jar'))
						if (javadocJar.exists()) {
							
							// 4. 在 .iml 中找到对应的 library 节点，并注入 javadoc 路径
							// 这里的逻辑稍微有点 trick，因为 fileTree 依赖在 .iml 里通常是一个 module-library 节点
							orderEntries.each { entry ->
								if (entry.@type == 'module-library') {
									def libraryTable = entry.library
									def classesRoot = libraryTable.CLASSES.root
									// 如果这个 library 节点的 CLASSES 路径指向当前的 Jar
									if (classesRoot && classesRoot.@url && classesRoot.@url.contains(file.name)) {
										// [核心操作] 注入 JAVADOC 节点
										def javadocNode = libraryTable.find { it.name() == 'JAVADOC' }
										if (!javadocNode) {
											javadocNode = libraryTable.appendNode('JAVADOC')
										}
										// 添加 javadoc 路径 (格式: jar://$PROJECT_DIR$/libs/xxx-javadoc.jar!/)
										def javadocUrl = "jar://\$PROJECT_DIR\$/libs/${javadocJar.name}!/"
										// 避免重复添加
										if (!javadocNode.root.find { it.@url == javadocUrl }) {
											javadocNode.appendNode('root', [url: javadocUrl])
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}
