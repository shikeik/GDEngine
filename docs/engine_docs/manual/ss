老师，收到。严谨性是文档的生命线。

我已重新查阅了 `core` 模块下 `ecs/`, `scripting/` 以及 `GameWorld.java` 的源码，对之前的草稿进行了**去伪存真**的修正。

以下是 **100% 基于当前源码实现** 的核心文档重写。

---

### 1. `docs/engine_docs/manual/core_concepts/ecs.md`

**修正点：**
*   明确了 `GObject` 强制包含 `TransformComponent` 的事实。
*   修正了 System 的注册方式（通过构造函数自动注册）和筛选机制（`@GameSystemInfo`）。
*   明确了 `ComponentManager` 的位掩码（BitSet）索引机制。

```markdown
# ECS 架构详解

GDEngine 的 ECS (Entity-Component-System) 实现了数据与逻辑的分离，但保留了类似 Unity 的层级图（Scene Graph）易用性。

## 1. Entity (实体)
**对应类：** `com.goldsprite.gdengine.ecs.entity.GObject`

实体是场景中的基本单元。
*   **强制组件：** 每个 `GObject` 在构造时会自动添加一个 `TransformComponent`，不可移除。
*   **层级关系：** 支持父子嵌套 (`setParent`)。子物体的变换（位移/旋转/缩放）是相对于父物体的。
*   **生命周期：** 由 `GameWorld` 的 `rootEntities` 列表管理顶层物体，子物体由父级递归驱动。

## 2. Component (组件)
**对应类：** `com.goldsprite.gdengine.ecs.component.Component`

组件是数据的载体，也可以包含针对单个物体的逻辑。
*   **依赖注入：** 组件被添加时，会自动注入 `gobject` 和 `transform` 引用。
*   **多态支持：** `getComponent(Class)` 支持查找子类组件。
*   **核心组件：**
    *   `TransformComponent`: 核心变换，维护 Local 和 World 两套矩阵。
    *   `SpriteComponent`: 基础图片渲染。
    *   `NeonAnimatorComponent`: 骨骼动画控制器。

## 3. System (系统)
**对应类：** `com.goldsprite.gdengine.ecs.system.BaseSystem`

系统负责处理特定类型的组件集合。

### 注册与筛选
系统在实例化时会自动注册到 `GameWorld`。系统必须通过注解声明它关心的组件：

```java
@GameSystemInfo(
    type = SystemType.UPDATE,
    interestComponents = { SkeletonComponent.class }
)
public class SkeletonSystem extends BaseSystem {
    @Override
    public void update(float delta) {
        // 这里的 getInterestEntities() 会利用 ComponentManager 的缓存
        // 仅返回持有 SkeletonComponent 的实体，O(1) 复杂度
        List<GObject> targets = getInterestEntities();
        for (GObject obj : targets) {
            // ...
        }
    }
}
```

### 内置核心系统
*   **SceneSystem:** 驱动所有 `GObject` 的 `update` 和生命周期（Start/Destroy）。
*   **WorldRenderSystem:** 收集所有 `RenderComponent`，按 Layer 排序并绘制。
```

---

### 2. `docs/engine_docs/manual/core_concepts/lifecycle.md`

**修正点：**
*   **严格区分：** `Awake` 是立即执行，`Start` 是延迟执行。
*   **严格区分：** `Update` (逻辑循环) 和 `Render` (渲染循环) 是分开调用的。
*   **物理步长：** 明确了 `FixedUpdate` 的累积器逻辑 (`accumulator`).
*   **编辑模式：** 明确了 `@ExecuteInEditMode` 的作用。

```markdown
# 生命周期 (Lifecycle)

理解引擎的执行顺序对于编写正确的逻辑至关重要。

## 1. 初始化阶段

### Awake (立即苏醒)
*   **触发时机：** 当你调用 `gobject.addComponent(...)` 的那一瞬间。
*   **用途：** 初始化组件自身的变量，获取同物体上的其他组件引用 (`getComponent`)。
*   **注意：** 此时物体可能还没被加入到场景树中。

### Start (延迟开始)
*   **触发时机：**
    1. 游戏进入 Play 模式的第一帧。
    2. 或者组件在运行中被动态添加后的**下一帧**逻辑开始前。
*   **用途：** 初始化跨物体的引用（例如 `world.findObject`），因为此时所有物体都已 Awake 完毕。

## 2. 游戏循环 (Game Loop)

每一帧 (`GameWorld.update(delta)`) 的执行顺序如下：

1.  **Flush (前置清理):** 处理上一帧产生的 `new GObject()` 或 `destroy()` 请求，同步 `rootEntities` 列表。
2.  **Late Start:** 执行所有待定组件的 `onStart()`。
3.  **Fixed Update (物理循环):**
    *   使用固定步长 (`0.0166s` / 60FPS)。
    *   如果发生了卡顿，该循环可能会在一帧内执行多次以追赶时间。
    *   **用途：** 物理计算、稳定的移动逻辑。
4.  **Update (逻辑循环):**
    *   使用可变步长 (`delta`)。
    *   `SceneSystem` 会遍历所有物体调用其 `onUpdate()`。
    *   **用途：** 输入处理、动画状态机更新、非物理移动。
5.  **Destroy (收尸):**
    *   执行本帧内被标记为 `destroy()` 的物体的清理逻辑。
6.  **Flush (后置清理):** 彻底移除被销毁物体的引用。

## 3. 渲染循环 (Render Loop)

渲染独立于逻辑更新，在 `GameRunnerScreen.render` 中调用：

1.  **System Render:** 遍历所有 `SystemType.RENDER` 类型的系统。
2.  **WorldRenderSystem:**
    *   收集所有激活的 `RenderComponent`。
    *   根据 `sortingLayer` 和 `orderInLayer` 进行排序。
    *   批量提交给 GPU (`NeonBatch`)。

## 4. 运行模式

*   **PLAY 模式:** 执行上述所有生命周期。
*   **EDIT 模式 (编辑器):**
    *   **不执行** `Update` / `FixedUpdate` / `Start`。
    *   **例外：** 如果组件类标记了 `@ExecuteInEditMode`，则会在编辑器中执行 `onUpdate` (常用于可视化调试、Gizmo 绘制)。
```

---

### 3. `docs/engine_docs/manual/core_concepts/resources.md`

**修正点：**
*   **核心类更正：** 强调 `ScriptResourceTracker` 的作用。它是防止脚本内存泄漏的防火墙。
*   **路径上下文：** 明确 `GameWorld.projectAssetsRoot` 的存在，解释为什么不需要写绝对路径。
*   **销毁机制：** 解释 Stop Game 时的自动释放原理。

```markdown
# 资源管理

GDEngine 的脚本系统运行在 JVM 上，但底层的图形资源（Texture, Shader）是不受 GC 管理的 Native 内存。因此，正确的资源管理至关重要。

## 资源路径
所有资源文件必须存放在项目的 `assets/` 目录下。
在脚本中引用资源时，**始终使用相对路径**。

*   文件位置：`MyProject/assets/sprites/hero.png`
*   代码引用：`"sprites/hero.png"`

## 脚本资源加载器 (ScriptResourceTracker)

为了防止用户编写的脚本导致内存泄漏，引擎提供了托管的加载工具类 `ScriptResourceTracker`。

### 加载纹理
```java
// ✅ 正确做法：使用 Tracker 加载
// 如果文件不存在，会返回 null 并打印日志，不会崩溃。
Texture tex = ScriptResourceTracker.loadTexture("sprites/hero.png");

// ❌ 错误做法：直接使用 Gdx API
// 这种方式加载的资源，在停止游戏时不会被自动释放，多次运行会导致显存溢出！
Texture riskyTex = new Texture(Gdx.files.internal("sprites/hero.png"));
```

### 加载图集区域
支持加载 TexturePacker 打包的 `.atlas` 文件或特殊命名规则的图片。

```java
// 加载名为 "jump_01" 的区域
TextureRegion reg = ScriptResourceTracker.loadRegion("sprites/hero.png#jump_01");
```

## 自动回收机制
1.  当您点击编辑器的 **Run Game** 时，脚本开始运行，通过 `ScriptResourceTracker` 加载的资源会被记录到一个列表中。
2.  当您点击 **Stop** 时，引擎会遍历该列表，强制调用所有资源的 `dispose()` 方法。
3.  因此，**不要**在 `onDestroy()` 中手动 dispose 通过 Tracker 加载的资源，否则可能导致二次释放错误。

*只有您通过 `new` 关键字手动创建的资源（如 `new Pixmap(...)`），才需要您自己管理生命周期。*
```

---

请确认这些内容是否符合您的要求，如果无误，我将把它们写入文件。
