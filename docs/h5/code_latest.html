<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>PHANTOM EDGE: v18 INTEGRATED</title>
    <style>
        /* --- Âü∫Á°ÄÁéØÂ¢É --- */
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Courier New', sans-serif; touch-action: none; user-select: none; -webkit-user-select: none; color: #fff; }
        #game-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; overflow: hidden; background: #000; }
        canvas { display: block; width: 100%; height: 100%; }

        /* --- UI: HUD (v16‰øùÁïô) --- */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; padding: 20px; box-sizing: border-box; display: flex; flex-direction: column; justify-content: space-between; z-index: 10; }
        .hud-top { display: flex; justify-content: space-between; width: 100%; }
        .bar-box { width: 42%; position: relative; }
        .name-tag { color: #fff; font-weight: 900; font-size: 16px; margin-bottom: 4px; text-shadow: 0 0 5px currentColor; display:flex; justify-content: space-between; align-items: flex-end;}
        .hp-frame { height: 16px; background: rgba(30,30,30,0.8); border: 2px solid #555; transform: skewX(-20deg); overflow: hidden; position: relative; }
        .hp-fill { height: 100%; width: 100%; transition: width 0.1s linear; }
        .hp-bg-damage { position:absolute; top:0; left:0; height:100%; width:100%; background: #fff; transition: width 0.5s 0.2s; z-index: -1; }
        .mp-frame { height: 6px; width: 80%; background: #111; border: 1px solid #333; margin-top: 4px; transform: skewX(-20deg); }
        .mp-fill { height: 100%; width: 0%; background: #00eaff; box-shadow: 0 0 10px #00eaff; transition: width 0.1s; }
        /* Áé©ÂÆ∂È¢úËâ≤ */
        #p1-bar .name-tag { color: #00eaff; }
        #p1-hp { background: linear-gradient(90deg, #00eaff, #0088aa); float: right; }
        #p1-mp-frame { float: right; }
        #p2-bar .name-tag { color: #ff0055; flex-direction: row-reverse; }
        #p2-hp { background: linear-gradient(90deg, #ff0055, #aa0033); float: left; }
        
        /* ËøûÂáªÂ≠óÊ†∑ (v15) */
        #combo-display {
            position: fixed; top: 80px; right: 40px; text-align: right; 
            font-size: 50px; font-weight: 900; font-style: italic; color: #ffeb3b; 
            text-shadow: 4px 4px 0 #000; opacity: 0; transform-origin: right center; z-index: 20;
        }
        #clash-display { 
            position: absolute; top: 20%; left: 50%; transform: translateX(-50%); 
            font-size: 80px; color: #fff; text-shadow: 0 0 20px #fff; opacity: 0; letter-spacing: 5px; pointer-events: none; 
        }

        /* --- UI: È°∂ÈÉ®ÊåâÈíÆÁªÑ (v17) --- */
        .top-bar {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 10px; z-index: 100; pointer-events: auto;
        }
        .ui-btn {
            background: rgba(0,0,0,0.6); border: 1px solid #00eaff; color: #00eaff;
            width: 30px; height: 30px; border-radius: 4px; 
            font-weight: bold; cursor: pointer; font-size: 12px;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 0 5px rgba(0,234,255,0.2);
        }
        .ui-btn:active { background: #00eaff; color: #000; }
        #btn-lang { width: 40px; border-color: #fff; color: #fff; }

        /* --- UI: Á¥ßÂáëÂûãÊåá‰ª§ÂéÜÂè≤ (v17) --- */
        #ui-history {
            position: absolute; top: 60px; left: 10px; width: 160px; bottom: 250px;
            pointer-events: none; display: flex; flex-direction: column-reverse;
            gap: 2px; overflow: hidden; max-height: 200px; z-index: 20;
        }
        .hist-item {
            background: rgba(0,0,0,0.8); border-left: 3px solid #555;
            padding: 3px 6px; font-size: 11px; color: #ccc;
            display: flex; align-items: center; justify-content: space-between;
            animation: slideIn 0.1s forwards; flex-shrink: 0; height: 22px;
        }
        @keyframes slideIn { from { opacity: 0; transform: translateX(-10px); } to { opacity: 1; transform: translateX(0); } }
        .hist-item.type-move { border-color: #00eaff; background: linear-gradient(90deg, rgba(0,234,255,0.2), transparent); color: #fff; font-weight: bold; }
        .hist-left { display: flex; align-items: center; }
        .icon { width: 16px; text-align: center; margin-right: 4px; font-weight: bold; }
        .src { font-size: 9px; color: #777; }

        /* --- UI: Ê®°ÊÄÅÁ™ó (v17) --- */
        #help-modal {
            position: absolute; inset: 0; background: rgba(0,0,0,0.9); z-index: 200;
            display: none; flex-direction: column; align-items: center; justify-content: center;
            backdrop-filter: blur(5px);
        }
        .help-container {
            width: 90%; max-width: 500px; background: #1a1a1a; 
            border: 1px solid #00eaff; box-shadow: 0 0 20px rgba(0,234,255,0.1);
            display: flex; flex-direction: column;
        }
        .tabs { display: flex; border-bottom: 1px solid #333; }
        .tab-btn {
            flex: 1; padding: 15px; text-align: center; cursor: pointer;
            color: #888; background: #111; font-weight: bold; font-size: 14px; transition: 0.2s;
        }
        .tab-btn.active { color: #00eaff; background: #1a1a1a; border-bottom: 2px solid #00eaff; }
        .tab-content { display: none; padding: 20px; min-height: 220px; }
        .tab-content.active { display: block; animation: fadeIn 0.2s; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        
        table { border-collapse: collapse; width: 100%; font-size: 12px; }
        th { color: #00eaff; text-align: left; padding: 8px; border-bottom: 1px solid #333; }
        td { padding: 8px; border-bottom: 1px solid #222; color: #ddd; }
        .close-hint { padding: 15px; text-align: center; color: #555; cursor: pointer; border-top: 1px solid #333; font-size: 10px; }
        .special-move { color: #ffeb3b; font-weight: bold; }

        /* --- UI: Toast (v17) --- */
        #ui-log { position: absolute; bottom: 20%; left: 50%; transform: translateX(-50%); text-align: center; pointer-events: none; text-shadow: 0 0 5px #000; z-index: 20; }
        .log-msg { font-size: 20px; color: #ffeb3b; font-weight: 900; margin-top: 5px; opacity: 0; transition: opacity 0.5s; }

        /* --- Êéß‰ª∂ (v17) --- */
        #controls-layer { position: absolute; inset: 0; pointer-events: none; z-index: 15; }
        .joystick-base {
            position: absolute; bottom: 40px; left: 40px; width: 140px; height: 140px;
            border-radius: 50%; border: 2px solid rgba(255,255,255,0.1);
            background: rgba(0,0,0,0.3); pointer-events: auto;
        }
        .joy-thumb {
            position: absolute; top: 50%; left: 50%; width: 50px; height: 50px;
            margin: -25px; background: rgba(0, 234, 255, 0.5); border-radius: 50%;
            transform: translate(0,0); transition: transform 0.05s;
        }
        .joy-slot {
            position: absolute; width: 6px; height: 6px; background: #666; border-radius: 50%;
            top: 50%; left: 50%; margin: -3px; transform-origin: 0 0;
        }
        .joy-slot.active { background: #00eaff; box-shadow: 0 0 5px #00eaff; transform: scale(1.5); }
        .gesture-zone {
            position: absolute; bottom: 0; right: 0; width: 50%; height: 80%;
            border-left: 1px dashed rgba(255,255,255,0.1); pointer-events: auto;
        }
        .gesture-hint { position: absolute; bottom: 10px; right: 10px; color: #555; font-size: 10px; }

        /* --- ÂêØÂä®/ÁªìÁÆóÈÅÆÁΩ© --- */
        #start-overlay, #game-over-overlay {
            position: absolute; inset: 0; background: #000; z-index: 999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        #game-over-overlay { background: rgba(0,0,0,0.9); display: none; }
        
        #btn-start, #btn-restart {
            padding: 15px 40px; font-size: 20px; font-family: 'Courier New', sans-serif; font-weight: bold;
            background: transparent; color: #00eaff; border: 2px solid #00eaff;
            cursor: pointer; box-shadow: 0 0 15px rgba(0,234,255,0.2); transition: 0.2s;
        }
        #btn-restart { background: #fff; color: #000; border: none; box-shadow: 5px 5px 0 #555; transform: skewX(-10deg); }
        h1 { font-size: 40px; color: #fff; margin-bottom: 30px; text-shadow: 0 0 10px #00eaff; }
        .result-title { font-size: 80px; font-weight: 900; font-style: italic; margin-bottom: 20px; }
        .win-text { color: #00eaff; text-shadow: 0 0 30px #00eaff; }
        .lose-text { color: #ff0055; text-shadow: 0 0 30px #ff0055; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="canvas"></canvas>
    
    <!-- UI Layer -->
    <div id="ui-layer">
        <div class="hud-top">
            <div id="p1-bar" class="bar-box">
                <div class="name-tag"><span>P1</span><span>NEON</span></div>
                <div class="hp-frame">
                    <div class="hp-bg-damage" id="p1-hp-dmg"></div>
                    <div id="p1-hp" class="hp-fill"></div>
                </div>
                <div class="mp-frame" id="p1-mp-frame"><div id="p1-mp" class="mp-fill"></div></div>
            </div>
            <div id="p2-bar" class="bar-box">
                <div class="name-tag"><span>CPU</span><span>SHADOW</span></div>
                <div class="hp-frame">
                    <div class="hp-bg-damage" id="p2-hp-dmg"></div>
                    <div id="p2-hp" class="hp-fill"></div>
                </div>
                <div class="mp-frame"><div id="p2-mp" class="mp-fill"></div></div>
            </div>
        </div>
        <div id="combo-display"></div>
        <div id="clash-display">CLASH!!</div>
    </div>

    <!-- v17 Extra UI -->
    <div class="top-bar">
        <div id="btn-help" class="ui-btn">?</div>
        <div id="btn-lang" class="ui-btn">CN</div>
    </div>
    <div id="ui-history"></div>
    <div id="ui-log"></div>
    
    <!-- Modal -->
    <div id="help-modal">
        <div class="help-container">
            <div class="tabs">
                <div class="tab-btn active" data-tab="tab-controls" data-i18n="tab_ctrl">CONTROLS</div>
                <div class="tab-btn" data-tab="tab-moves" data-i18n="tab_moves">MOVES LIST</div>
            </div>
            <div id="tab-controls" class="tab-content active">
                <table>
                    <tr><th data-i18n="th_action">ACTION</th><th data-i18n="th_key">KEYBOARD</th><th data-i18n="th_touch">TOUCH</th></tr>
                    <tr><td data-i18n="act_move">Move</td><td>W A S D</td><td data-i18n="in_stick">Joystick</td></tr>
                    <tr><td data-i18n="act_jump">Jump</td><td>K</td><td data-i18n="in_swipe_u">Swipe Up</td></tr>
                    <tr><td data-i18n="act_atk">Attack</td><td>J</td><td data-i18n="in_tap">Tap</td></tr>
                    <tr><td data-i18n="act_ult">Ult</td><td>O</td><td data-i18n="in_swipe_d">Swipe Down</td></tr>
                </table>
            </div>
            <div id="tab-moves" class="tab-content">
                <table>
                    <tr><th data-i18n="th_skill">SKILL</th><th data-i18n="th_key">KEYBOARD</th><th data-i18n="th_touch">TOUCH</th></tr>
                    <tr><td data-i18n="skl_dash_l">Dash (Left)</td><td data-i18n="key_dash_l">Hold A + L</td><td data-i18n="tch_dash_l">Swipe Left</td></tr>
                    <tr><td data-i18n="skl_dash_r">Dash (Right)</td><td data-i18n="key_dash_r">Hold D + L</td><td data-i18n="tch_dash_r">Swipe Right</td></tr>
                    <tr><td data-i18n="skl_dash_a">Dash (Auto)</td><td data-i18n="key_dash_a">Press L</td><td data-i18n="tch_dash_a">-</td></tr>
                    <tr><td class="special-move" data-i18n="skl_flash">Flash Slash</td><td data-i18n="key_flash">Hold S + L</td><td data-i18n="tch_flash">Stick Down + Swipe</td></tr>
                </table>
            </div>
            <div class="close-hint" id="btn-close-help" data-i18n="btn_close">TAP ANYWHERE TO CLOSE</div>
        </div>
    </div>

    <!-- Controls -->
    <div id="controls-layer">
        <div class="joystick-base" id="stick-base">
            <div class="joy-thumb" id="stick-thumb"></div>
        </div>
        <div class="gesture-zone" id="gesture-pad">
            <div class="gesture-hint" data-i18n="hint_swipe">SWIPE AREA</div>
        </div>
    </div>
</div>

<div id="start-overlay">
    <h1>PHANTOM EDGE</h1>
    <p>v18 INTEGRATED</p>
    <button id="btn-start" data-i18n="btn_start">START FULLSCREEN</button>
</div>

<div id="game-over-overlay">
    <div id="result-title" class="result-title">VICTORY</div>
    <button id="btn-restart">RETRY MISSION</button>
</div>

<script>
/**
 * AUDIO ENGINE
 */
const AudioSys = {
    ctx: null,
    init() {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
    },
    playTone(freq, type, duration, vol=0.1, slide=0) {
        if(!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        if(slide) osc.frequency.exponentialRampToValueAtTime(slide, this.ctx.currentTime + duration);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain); gain.connect(this.ctx.destination);
        osc.start(); osc.stop(this.ctx.currentTime + duration);
    },
    noise(duration, vol=0.2) {
        if(!this.ctx) return;
        const bSize = this.ctx.sampleRate * duration;
        const buf = this.ctx.createBuffer(1, bSize, this.ctx.sampleRate);
        const data = buf.getChannelData(0);
        for(let i=0; i<bSize; i++) data[i] = Math.random() * 2 - 1;
        const src = this.ctx.createBufferSource();
        src.buffer = buf;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        src.connect(gain); gain.connect(this.ctx.destination);
        src.start();
    },
    sfx: {
        swing: () => AudioSys.noise(0.1, 0.1),
        hit: () => { AudioSys.noise(0.2, 0.3); AudioSys.playTone(100, 'sawtooth', 0.2, 0.2, 50); },
        clash: () => { AudioSys.playTone(800, 'square', 0.1, 0.3); AudioSys.playTone(1200, 'sine', 0.3, 0.3, 100); },
        jump: () => AudioSys.playTone(200, 'sine', 0.2, 0.1, 400),
        ultCast: () => { AudioSys.playTone(50, 'square', 1.0, 0.2); AudioSys.playTone(1000, 'sawtooth', 1.0, 0.1, 100); },
        slash: () => { AudioSys.noise(0.05, 0.2); AudioSys.playTone(2000, 'triangle', 0.05, 0.1, 1000); },
        ultBoom: () => { AudioSys.noise(1.0, 0.8); AudioSys.playTone(50, 'sawtooth', 1.5, 0.5, 10); }
    }
};

/** I18N SYSTEM (v17) */
const LANG_DB = {
    'zh': {
        'tab_ctrl': 'Êìç‰ΩúËØ¥Êòé', 'tab_moves': 'Âá∫ÊãõË°®',
        'th_action': 'Âä®‰Ωú', 'th_key': 'ÈîÆÁõò', 'th_touch': 'Ëß¶Â±è', 'th_skill': 'ÊãõÂºè', 
        'act_move': 'ÁßªÂä®', 'act_jump': 'Ë∑≥Ë∑É', 'act_atk': 'ÊîªÂáª', 'act_ult': 'Â§ßÊãõ',
        'in_stick': 'ÊëáÊùÜ', 'in_swipe_u': '‰∏äÊªë', 'in_swipe_d': '‰∏ãÊªë', 'in_tap': 'ÁÇπÂáª',
        'skl_dash_l': 'Â∑¶ÂÜ≤Âà∫', 'skl_dash_r': 'Âè≥ÂÜ≤Âà∫', 'skl_dash_a': 'ÂÜ≤Âà∫ (Ëá™Âä®)', 'skl_flash': 'Èó™ ÂàÄ',
        'key_dash_l': 'Êåâ‰Ωè A + L', 'tch_dash_l': 'Â∑¶Êªë',
        'key_dash_r': 'Êåâ‰Ωè D + L', 'tch_dash_r': 'Âè≥Êªë',
        'key_dash_a': 'ÂçïÊåâ L',     'tch_dash_a': '-',
        'key_flash': 'Êåâ‰Ωè S + L',  'tch_flash': 'ÊëáÊùÜ‰∏ã + ÂàíÂ±è',
        'btn_close': 'ÁÇπÂáª‰ªªÊÑèÂ§ÑÂÖ≥Èó≠', 'hint_swipe': 'ÊâãÂäøÂå∫Âüü', 'btn_start': 'ÂºÄÂßãÊàòÊñó',
        'CMD_MOVE_LEFT': 'Â∑¶Áßª', 'CMD_MOVE_RIGHT': 'Âè≥Áßª', 'CMD_CROUCH': '‰∏ãËπ≤',
        'CMD_JUMP': 'Ë∑≥Ë∑É', 'CMD_ATK': 'ÊîªÂáª', 'CMD_ULT': 'Â§ßÊãõ',
        'CMD_DASH_L': 'Â∑¶ÂÜ≤', 'CMD_DASH_R': 'Âè≥ÂÜ≤', 'CMD_DASH_AUTO': 'ÂÜ≤Âà∫',
        'FLASH SLASH': 'Èó™ ÂàÄ', 'DASH': 'ÂÜ≤ Âà∫', 'ATTACK': 'Êîª Âáª', 'JUMP': 'Ë∑≥ Ë∑É', 'ULTIMATE': 'Â§ß Êãõ',
        'KEY': 'ÊåâÈîÆ', 'STICK': 'ÊëáÊùÜ', 'GESTURE': 'ÊâãÂäø'
    },
    'en': {
        'tab_ctrl': 'CONTROLS', 'tab_moves': 'MOVES LIST',
        'th_action': 'ACTION', 'th_key': 'KEYBOARD', 'th_touch': 'TOUCH', 'th_skill': 'SKILL', 
        'act_move': 'Move', 'act_jump': 'Jump', 'act_atk': 'Attack', 'act_ult': 'Ult',
        'in_stick': 'Joystick', 'in_swipe_u': 'Swipe Up', 'in_swipe_d': 'Swipe Down', 'in_tap': 'Tap',
        'skl_dash_l': 'Dash (Left)', 'skl_dash_r': 'Dash (Right)', 'skl_dash_a': 'Dash (Auto)', 'skl_flash': 'Flash Slash',
        'key_dash_l': 'Hold A + L', 'tch_dash_l': 'Swipe Left',
        'key_dash_r': 'Hold D + L', 'tch_dash_r': 'Swipe Right',
        'key_dash_a': 'Press L',    'tch_dash_a': '-',
        'key_flash': 'Hold S + L',  'tch_flash': 'Stick Down + Swipe',
        'btn_close': 'TAP ANYWHERE TO CLOSE', 'hint_swipe': 'SWIPE AREA', 'btn_start': 'START BATTLE',
        'CMD_MOVE_LEFT': 'LEFT', 'CMD_MOVE_RIGHT': 'RIGHT', 'CMD_CROUCH': 'CROUCH',
        'CMD_JUMP': 'JUMP', 'CMD_ATK': 'ATK', 'CMD_ULT': 'ULT',
        'CMD_DASH_L': 'DASH L', 'CMD_DASH_R': 'DASH R', 'CMD_DASH_AUTO': 'DASH',
        'FLASH SLASH': 'FLASH SLASH', 'DASH': 'DASH', 'ATTACK': 'ATTACK', 'JUMP': 'JUMP', 'ULTIMATE': 'ULTIMATE',
        'KEY': 'Key', 'STICK': 'Stick', 'GESTURE': 'Gesture'
    }
};
const I18N = {
    lang: localStorage.getItem('app_lang') || 'zh',
    init() {
        this.apply();
        document.getElementById('btn-lang').onclick = () => {
            this.lang = this.lang === 'zh' ? 'en' : 'zh';
            localStorage.setItem('app_lang', this.lang);
            this.apply();
        };
    },
    apply() {
        document.documentElement.lang = this.lang === 'zh' ? 'zh-CN' : 'en';
        document.getElementById('btn-lang').innerText = this.lang.toUpperCase();
        document.querySelectorAll('[data-i18n]').forEach(el => {
            let key = el.dataset.i18n;
            if(LANG_DB[this.lang][key]) el.innerHTML = LANG_DB[this.lang][key];
        });
    },
    t(key) { return LANG_DB[this.lang][key] || key; }
};

/** COMMAND MANIFEST */
const COMMAND_MANIFEST = [
    { id: 'CMD_MOVE_LEFT',  type: 'STATE', icon: '‚¨Ö',  triggers: [{hw:'KEY', code:'KeyA'}, {hw:'STICK', dir:'LEFT'}] },
    { id: 'CMD_MOVE_RIGHT', type: 'STATE', icon: '‚û°',  triggers: [{hw:'KEY', code:'KeyD'}, {hw:'STICK', dir:'RIGHT'}] },
    { id: 'CMD_CROUCH',     type: 'STATE', icon: '‚¨á',  triggers: [{hw:'KEY', code:'KeyS'}, {hw:'STICK', dir:'DOWN'}] },
    { id: 'CMD_JUMP',       type: 'TRIG',  icon: '‚¨Ü',  triggers: [{hw:'KEY', code:'KeyK'}, {hw:'GESTURE', id:'SWIPE_UP'}] },
    { id: 'CMD_ATK',        type: 'TRIG',  icon: '‚öîÔ∏è', triggers: [{hw:'KEY', code:'KeyJ'}, {hw:'GESTURE', id:'TAP'}] },
    { id: 'CMD_ULT',        type: 'TRIG',  icon: '‚≠ï',  triggers: [{hw:'KEY', code:'KeyO'}, {hw:'GESTURE', id:'SWIPE_DOWN'}] },
    { id: 'CMD_DASH_L', type: 'TRIG', icon: '‚è™', triggers: [{ hw: 'GESTURE', id: 'SWIPE_LEFT' }, { hw: 'KEY', code: 'KeyL', mod: 'KeyA' }] },
    { id: 'CMD_DASH_R', type: 'TRIG', icon: '‚è©', triggers: [{ hw: 'GESTURE', id: 'SWIPE_RIGHT' }, { hw: 'KEY', code: 'KeyL', mod: 'KeyD' }] },
    { id: 'CMD_DASH_AUTO', type: 'TRIG', icon: 'üöÄ', triggers: [{ hw: 'KEY', code: 'KeyL', mod: null }] }
];

/** GAME SYSTEM */
const platforms = [ { x: 200, y: 350, w: 200, h: 20 }, { x: 600, y: 200, w: 200, h: 20 }, { x: 450, y: 300, w: 100, h: 20 } ];
let particles = [];
let slashLines = [];
let damageTexts = [];
let afterimages = [];
let lightningTrails = [];
let gestureTrails = [];
let uiCombo = 0;
let uiComboTimer = null;

class Particle {
    constructor(x, y, color, speed, size, life, type='box') {
        this.x = x; this.y = y; this.color = color;
        this.vx = (Math.random()-0.5)*speed; this.vy = (Math.random()-0.5)*speed;
        this.life = life; this.maxLife = life; this.size = size; this.type = type;
        if(type==='shard') { this.rotation = Math.random()*6; this.vRot = (Math.random()-0.5)*0.5; }
    }
    update() {
        this.x += this.vx * Game.timeScale; this.y += this.vy * Game.timeScale;
        this.life -= 0.02 * Game.timeScale;
        if(this.type === 'shard') this.rotation += this.vRot * Game.timeScale;
    }
    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life/this.maxLife);
        ctx.fillStyle = this.color;
        if(this.type === 'box') {
            ctx.fillRect(this.x, this.y, this.size, this.size);
        } else if (this.type === 'shard') {
            ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation);
            ctx.beginPath(); ctx.moveTo(-this.size, this.size); ctx.lineTo(0, -this.size); ctx.lineTo(this.size, this.size); ctx.fill();
            ctx.restore();
        }
        ctx.globalAlpha = 1;
    }
}

class DamageText {
    constructor(x, y, dmg, isCrit) {
        this.x = x + (Math.random()-0.5)*20; this.y = y - 20;
        this.text = Math.floor(dmg);
        this.vy = -3 - Math.random()*2; this.vx = (Math.random()-0.5)*2;
        this.life = 1.0; this.color = isCrit ? '#ffeb3b' : '#fff'; this.scale = isCrit ? 1.5 : 1.0;
    }
    update() {
        this.x += this.vx * Game.timeScale; this.y += this.vy * Game.timeScale;
        this.vy += 0.15 * Game.timeScale; this.life -= 0.02 * Game.timeScale;
    }
    draw(ctx) {
        ctx.save(); ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color; ctx.shadowBlur = 0;
        ctx.font = `900 ${20 * this.scale}px 'Courier New'`; ctx.textAlign = 'center';
        ctx.fillText(this.text, this.x, this.y); ctx.strokeText(this.text, this.x, this.y);
        ctx.restore();
    }
}

function drawStickmanFigure(ctx, state, animTimer) {
    ctx.beginPath();
    if(state === 'jump' || state === 'dash' || state === 'flash_slash') {
        ctx.moveTo(-10, -40); ctx.lineTo(-25, -15); ctx.moveTo(10, -40); ctx.lineTo(25, -25);
    } else if (state === 'run') {
        let cycle = Math.sin(animTimer*0.5)*15;
        ctx.moveTo(-10, -40); ctx.lineTo(-20+cycle, 0); ctx.moveTo(10, -40); ctx.lineTo(20-cycle, 0);
    } else { 
        ctx.moveTo(-10, -40); ctx.lineTo(-20, 0); ctx.moveTo(10, -40); ctx.lineTo(20, 0);
    }
    ctx.stroke();
    // Body & Visual Crouch (Flash Slash Ready)
    if((state === 'flash_slash' && animTimer < 5) || (state==='idle' && InputSystem.virtualState.crouch)) {
        ctx.fillRect(-15, -60, 30, 30); // Low body
    } else {
        ctx.fillRect(-15, -80, 30, 40);
    }
    // Head
    ctx.beginPath(); 
    let headY = ((state === 'flash_slash' && animTimer < 5) || (state==='idle' && InputSystem.virtualState.crouch)) ? -65 : -90;
    ctx.arc(0, headY, 12, 0, Math.PI*2); ctx.fill();
    // Arms
    ctx.beginPath();
    if(state === 'attack') {
        ctx.moveTo(-10, -70); ctx.lineTo(-20, -40); ctx.moveTo(10, -70); ctx.lineTo(40, -70);
    } else if (state === 'flash_slash' && animTimer < 5) {
        ctx.moveTo(-10, -60); ctx.lineTo(10, -50); ctx.moveTo(10, -60); ctx.lineTo(30, -50);
    } else if (state === 'ult_cast' || state === 'ult_end') {
        ctx.moveTo(-10, -70); ctx.lineTo(-30, -50); ctx.moveTo(10, -70); ctx.lineTo(30, -50); ctx.moveTo(-35, -55); ctx.lineTo(-50, -70);
    } else {
        let armS = state==='run' ? Math.sin(animTimer*0.5)*15 : 0;
        ctx.moveTo(-10, -70); ctx.lineTo(-20+armS, -30); ctx.moveTo(10, -70); ctx.lineTo(20-armS, -30);
    }
    ctx.stroke();
}

class Afterimage {
    constructor(x, y, dir, state, animTimer, color) {
        this.x = x; this.y = y; this.dir = dir; this.state = state; this.animTimer = animTimer; this.color = color;
        this.life = 1.0; this.decay = 0.1;
    }
    update() { this.life -= this.decay; }
    draw(ctx) {
        if(this.life <= 0) return;
        ctx.save(); ctx.translate(this.x + 20, this.y + 90); ctx.scale(this.dir, 1);
        ctx.globalAlpha = this.life * 0.5; ctx.strokeStyle = this.color; ctx.fillStyle = this.color;
        ctx.lineWidth = 2; ctx.shadowBlur = 0;
        drawStickmanFigure(ctx, this.state, this.animTimer);
        ctx.restore();
    }
}

class LightningTrail {
    constructor(x1, y1, x2, y2) {
        this.path = []; this.origPath = []; this.timer = 15;
        let steps = 10; let dx = (x2-x1)/steps; let dy = (y2-y1)/steps;
        this.origPath.push({x:x1, y:y1});
        for(let i=1; i<steps; i++) this.origPath.push({x: x1 + dx*i, y: y1 + dy*i + (Math.random()-0.5)*40});
        this.origPath.push({x:x2, y:y2});
        this.path = JSON.parse(JSON.stringify(this.origPath));
    }
    draw(ctx) {
        if(this.timer <= 0) return;
        if(this.timer > 0) {
            for(let i=1; i<this.path.length-1; i++) {
                this.path[i].x = this.origPath[i].x + (Math.random()-0.5)*10;
                this.path[i].y = this.origPath[i].y + (Math.random()-0.5)*10;
            }
        }
        ctx.save(); ctx.beginPath(); ctx.moveTo(this.path[0].x, this.path[0].y);
        for(let p of this.path) ctx.lineTo(p.x, p.y);
        let bloom = this.timer < 5 || this.timer % 3 === 0;
        ctx.lineWidth = bloom ? 5 : 2; ctx.strokeStyle = bloom ? '#fff' : '#00eaff'; ctx.shadowColor = '#00eaff'; ctx.shadowBlur = bloom ? 30 : 10;
        ctx.globalAlpha = this.timer / 15; ctx.stroke(); ctx.restore(); this.timer--;
    }
}

class GestureTrail {
    constructor(x1, y1, x2, y2, isTap) {
        this.start = {x:x1, y:y1}; this.life = 1.0; this.isTap = isTap;
        if (isTap) {
            this.end = {x:x1, y:y1};
        } else {
            let dx = x2 - x1, dy = y2 - y1; let len = Math.sqrt(dx*dx + dy*dy); if(len < 1) len = 1;
            let angle = Math.atan2(dy, dx); 
            let snappedAngle = Math.round(angle / (Math.PI/4)) * (Math.PI/4);
            this.end = { x: x1 + Math.cos(snappedAngle) * len, y: y1 + Math.sin(snappedAngle) * len };
            let ndx = this.end.x - this.start.x, ndy = this.end.y - this.start.y;
            this.nx = -ndy / len; this.ny = ndx / len; this.vx = (ndx / len); this.vy = (ndy / len);
        }
    }
    draw(ctx) {
        if(this.life <= 0) return;
        ctx.save(); ctx.globalAlpha = this.life * 0.8; ctx.fillStyle = '#fff'; ctx.shadowColor = '#fff'; ctx.shadowBlur = 10;
        ctx.beginPath();
        if (this.isTap) {
            let size = 30; ctx.moveTo(this.start.x, this.start.y - size); ctx.lineTo(this.start.x + size, this.start.y);
            ctx.lineTo(this.start.x, this.start.y + size); ctx.lineTo(this.start.x - size, this.start.y);
        } else {
            let wStart = 2, wEnd = 15, tipLen = 30;
            ctx.moveTo(this.start.x + this.nx*wStart, this.start.y + this.ny*wStart);
            ctx.lineTo(this.end.x + this.nx*wEnd, this.end.y + this.ny*wEnd);
            ctx.lineTo(this.end.x + this.vx*tipLen, this.end.y + this.vy*tipLen);
            ctx.lineTo(this.end.x - this.nx*wEnd, this.end.y - this.ny*wEnd);
            ctx.lineTo(this.start.x - this.nx*wStart, this.start.y - this.ny*wStart);
        }
        ctx.fill(); ctx.restore(); this.life -= 0.03;
    }
}

class Fighter {
    constructor(x, color, isAi) {
        this.x = x; this.y = 0; this.vx = 0; this.vy = 0; this.w = 40; this.h = 90;
        this.color = color; this.isAi = isAi; this.dir = 1;
        this.hp = 500; this.maxHp = 500; this.mp = 0;
        this.state = 'idle'; this.animTimer = 0; this.combo = 0; this.inAir = false;
        this.ultTimer = 0; this.target = null;
    }

    // New Command Interface
    handleCommand(cmd, params) {
        if(this.state === 'dead' || this.state === 'hit' || this.state.startsWith('ult') || this.state === 'flash_slash' || this.state === 'dash') return;

        if(cmd === 'JUMP' && !this.inAir) { this.vy = -20; this.state='jump'; AudioSys.sfx.jump(); }
        if(cmd === 'ATTACK') this.attack(p2); // p2 is global ref
        if(cmd === 'ULTIMATE') this.performUlt(p2);
        if(cmd === 'DASH') this.dash(params.dir);
        if(cmd === 'FLASH SLASH') this.flashSlash();
    }

    update(dt, enemy) {
        // AI Logic
        if(this.isAi && this.state !== 'dead' && this.state !== 'ult_frozen') {
            this.aiUpdate(enemy);
        } else if (!this.isAi) {
            // Player Logic (InputSystem)
            // Move: only if free state
            if(this.state === 'idle' || this.state === 'run' || this.state === 'jump') {
                this.vx = InputSystem.virtualState.moveX * 6;
                if(InputSystem.virtualState.moveX !== 0 && !this.inAir) this.state = 'run';
                else if (InputSystem.virtualState.moveX === 0 && !this.inAir) this.state = 'idle';
            }
        }

        // Physics
        this.vy += 0.8 * Game.timeScale;
        this.x += this.vx * Game.timeScale;
        this.y += this.vy * Game.timeScale;

        // Platform & Ground
        let onGround = false;
        const groundY = Game.logicH - 100;

        if (this.vy >= 0) {
            for (let p of platforms) {
                if (this.x + this.w > p.x && this.x < p.x + p.w &&
                    this.y + this.h >= p.y && this.y + this.h <= p.y + this.vy + 20) {
                    this.y = p.y - this.h; this.vy = 0; this.inAir = false; onGround = true;
                    if(this.state === 'jump' || this.state === 'hit') this.state = 'idle';
                    break;
                }
            }
        }
        if (!onGround) {
            if (this.y + this.h >= groundY) {
                this.y = groundY - this.h; this.vy = 0; this.inAir = false;
                if(this.state === 'jump' || this.state === 'hit') this.state = 'idle';
            } else { this.inAir = true; }
        }

        if(this.state !== 'dash' && this.state !== 'flash_slash' && !this.inAir && this.vx!==0) { /* friction handled by input */ }
        else if(this.state !== 'dash' && this.vx!==0) this.vx *= 0.8; // friction

        if(this.x < 0) this.x = 0;
        if(this.x > Game.logicW - this.w) this.x = Game.logicW - this.w;

        if(!this.isAi && (this.state==='idle'||this.state==='run')) {
            // Facing Logic: Auto face if input matches? Or input dictates?
            // Input system dictates movement. Facing usually follows movement.
            if(InputSystem.virtualState.moveX !== 0) this.dir = InputSystem.virtualState.moveX;
        } else if (this.state !== 'ult_cast' && this.state !== 'ult_slash' && this.state !== 'ult_end' && this.state !== 'dash' && this.state !== 'flash_slash') {
             if(enemy.x > this.x) this.dir = 1; else this.dir = -1;
        }

        this.animTimer += Game.timeScale;

        // --- SKILL STATES ---
        if(this.state === 'dash') {
            this.animTimer++; this.vy = 0;
            this.x += this.vx * Game.timeScale;
            if(this.animTimer % 2 === 0) afterimages.push(new Afterimage(this.x, this.y, this.dir, this.state, this.animTimer, this.color));
            if(this.animTimer > 10) { this.state = 'idle'; this.vx = 0; }
            // Wall check in dash
            if(this.x < 0) this.x = 0; if(this.x > Game.logicW - this.w) this.x = Game.logicW - this.w;
        }

        if(this.state === 'flash_slash') {
            this.animTimer++; this.vy = 0; this.vx = 0;
            // Phase 1: Charge
            if(this.animTimer === 1) AudioSys.playTone(800, 'sine', 0.1, 0.1, 50);
            // Phase 2: Teleport
            if(this.animTimer === 6) {
                let startX = this.slashStartX + this.w/2; let startY = this.y + this.h/2;
                this.x = this.flashTargetX; 
                if(this.x < 0) this.x = 0; if(this.x > Game.logicW-40) this.x = Game.logicW-40;
                let endX = this.x + this.w/2;
                lightningTrails.push(new LightningTrail(startX, startY, endX, startY));
                AudioSys.playTone(600, 'sawtooth', 0.1, 0.2, 2000);
            }
            // Phase 3: Bloom & Damage
            if(this.animTimer === 18) {
                AudioSys.noise(0.3, 0.5); Game.shake = 15;
                let minX = Math.min(this.slashStartX, this.flashTargetX);
                let maxX = Math.max(this.slashStartX, this.flashTargetX);
                if(enemy.x + enemy.w > minX && enemy.x < maxX && Math.abs(enemy.y - this.y) < 100) {
                    enemy.takeDamage(40, this.dir); uiCombo++; this.updateComboUI();
                }
            }
            if(this.animTimer > 25) this.state = 'idle';
        }

        // Ult Logic
        if(this.state === 'ult_cast') {
            this.ultTimer++;
            if(this.ultTimer > 40) {
                this.state = 'ult_slash'; this.ultTimer = 0;
                for(let i=0; i<15; i++) {
                    slashLines.push({
                        x: enemy.x + enemy.w/2 + (Math.random()-0.5)*200,
                        y: enemy.y + enemy.h/2 + (Math.random()-0.5)*200,
                        len: 100 + Math.random()*200, angle: Math.random() * Math.PI * 2,
                        delay: Math.random() * 30, life: 10
                    });
                }
            }
        } else if (this.state === 'ult_slash') {
            this.ultTimer++;
            if(this.ultTimer % 4 === 0) { AudioSys.sfx.slash(); Game.shake = 5; enemy.state = 'ult_frozen'; }
            if(this.ultTimer > 60) {
                this.state = 'ult_end'; this.ultTimer = 0;
                this.y = enemy.y; this.vy = 0; this.inAir = false; 
                let idealX = enemy.x - (enemy.dir * 100);
                if (idealX < 50 || idealX > Game.logicW - 90) idealX = enemy.x + (enemy.dir * 100);
                this.x = idealX; this.dir = (this.x < enemy.x) ? 1 : -1;
            }
        } else if (this.state === 'ult_end') {
            this.ultTimer++;
            if(this.ultTimer === 30) {
                AudioSys.sfx.ultBoom(); Game.shake = 40; Game.flash = 10; Game.timeScale = 1.0; Game.darkOverlay = 0;
                let dmg = 150; enemy.takeDamage(dmg, -this.dir);
                for(let i=0; i<30; i++) particles.push(new Particle(enemy.x + enemy.w/2, enemy.y + enemy.h/2, '#00eaff', 15, 8, 40, 'shard'));
                this.state = 'idle';
            }
        }
    }

    aiUpdate(target) {
        if(this.state === 'hit' || this.state === 'clash') return;
        let dist = Math.abs(this.x - target.x);
        if(dist > 80) { this.vx = 3 * (target.x > this.x ? 1 : -1); this.state = 'run'; } 
        else { this.vx = 0; this.state = 'idle'; if(Math.random() < 0.05 && target.state !== 'dead') this.attack(target); }
        if(this.mp >= 100 && dist < 200 && Math.random() < 0.01) this.performUlt(target);
    }

    attack(target) {
        if(this.state === 'attack' || this.state === 'hit' || this.state.startsWith('ult') || this.state === 'dash' || this.state === 'flash_slash') return;
        this.state = 'attack'; this.animTimer = 0; this.vx = 8 * this.dir; AudioSys.sfx.swing();
        setTimeout(() => {
            if(this.state !== 'attack') return;
            let range = 100;
            let hit = Math.abs((this.x+this.w/2) - (target.x+target.w/2)) < range && Math.abs(this.y - target.y) < 80;
            if(hit) {
                if(target.state === 'attack') { this.clash(target); } 
                else if (target.state !== 'ult_cast' && target.state !== 'ult_slash' && target.state !== 'dead' && target.state !== 'dash' && target.state !== 'flash_slash') {
                    Game.timeScale = 0.1; setTimeout(()=>Game.timeScale=1.0, 50); Game.shake = 10;
                    this.mp = Math.min(100, this.mp + 15);
                    target.takeDamage(15 + this.combo*5, this.dir); this.combo = (this.combo+1)%3;
                    if(!this.isAi) { uiCombo++; this.updateComboUI(); }
                }
            }
        }, 100 * (1/Game.timeScale)); // Use real time approximation
        setTimeout(() => { if(this.state==='attack') this.state='idle'; }, 300);
    }

    updateComboUI() {
        if(this.isAi) return;
        const el = document.getElementById('combo-display');
        el.innerText = uiCombo + " HITS"; el.style.opacity = 1;
        el.style.transition = 'none'; el.style.transform = "scale(1.5) rotate(-5deg)";
        void el.offsetWidth; 
        el.style.transition = 'transform 0.1s'; el.style.transform = "scale(1) rotate(0deg)";
        if(uiComboTimer) clearTimeout(uiComboTimer);
        uiComboTimer = setTimeout(() => { uiCombo = 0; el.style.opacity = 0; }, 2000);
    }
    
    clash(enemy) {
        this.state = 'clash'; enemy.state = 'clash';
        this.vx = -15 * this.dir; enemy.vx = -15 * enemy.dir;
        Game.shake = 20; AudioSys.sfx.clash();
        let midX = (this.x + enemy.x + this.w)/2; let midY = this.y + 40;
        for(let i=0; i<20; i++) particles.push(new Particle(midX, midY, '#fff', 10, 4, 20));
        const el = document.getElementById('clash-display');
        el.style.opacity = 1; el.style.transform = "translateX(-50%) scale(1.5)";
        setTimeout(()=> { el.style.opacity=0; el.style.transform="translateX(-50%) scale(1)"; }, 500);
        setTimeout(() => { if(this.state==='clash') this.state='idle'; if(enemy.state==='clash') enemy.state='idle'; }, 300);
    }

	takeDamage(amt, hitDir) {
        if(this.state === 'dead' || this.state === 'dash' || this.state === 'flash_slash' || (this.state.startsWith('ult') && this.state !== 'ult_frozen')) return;
        this.hp -= amt; this.state = 'hit'; this.vx = 10 * hitDir; this.vy = -5; AudioSys.sfx.hit();
        damageTexts.push(new DamageText(this.x+this.w/2, this.y, amt, uiCombo>3));
        for(let i=0; i<5; i++) particles.push(new Particle(this.x+this.w/2, this.y+40, this.color, 8, 4, 20));
        if(this.hp <= 0) {
            this.hp = 0; this.state = 'dead'; this.vx = 15*hitDir; this.vy = -10;
            endGame(this.isAi ? 'WIN' : 'LOSE');
        }
        setTimeout(() => { if(this.state==='hit') this.state='idle'; }, 400);
    }

    performUlt(target) {
        if(this.mp < 100) return;
        this.mp = 0; this.state = 'ult_cast'; this.ultTimer = 0; this.target = target;
        AudioSys.sfx.ultCast();
        Game.timeScale = 0.05; Game.darkOverlay = 0.8;
        target.state = 'ult_frozen'; target.vx = 0; target.vy = 0;
    }

    dash(dir) {
        if(dir === 0) dir = this.dir; 
        this.dir = dir; this.state = 'dash'; this.animTimer = 0; 
        this.vx = 25 * this.dir; AudioSys.noise(0.1, 0.1);
    }

    flashSlash() {
        this.state = 'flash_slash'; this.animTimer = 0; this.vx = 0;
        this.slashStartX = this.x; this.flashTargetX = this.x + (350 * this.dir);
    }

    draw(ctx) {
        if(this.state === 'ult_slash') return;
        if(this.state === 'flash_slash' && this.animTimer >= 6 && this.animTimer < 18) return;

        ctx.save();
        ctx.translate(this.x + this.w/2, this.y + this.h);
        ctx.scale(this.dir, 1);
        
        let isFlashCharge = (this.state === 'flash_slash' && this.animTimer < 6);
        if(isFlashCharge) {
            ctx.strokeStyle = '#fff'; ctx.shadowColor = '#fff'; ctx.shadowBlur = 40; ctx.fillStyle = '#fff';
        } else {
            ctx.strokeStyle = this.state==='dead' ? '#555' : this.color;
            ctx.shadowColor = this.color;
            ctx.shadowBlur = this.state.startsWith('ult') ? 30 : 10;
            ctx.fillStyle = this.color;
        }
        if(this.state === 'hit') { ctx.strokeStyle = '#fff'; ctx.shadowBlur = 0; }
        ctx.lineWidth = 4; ctx.lineCap = 'round'; ctx.lineJoin = 'round';

        drawStickmanFigure(ctx, this.state, this.animTimer);
        
        if(isFlashCharge) {
            ctx.restore(); ctx.save(); ctx.translate(this.x + this.w/2, this.y + this.h/2);
            ctx.beginPath(); ctx.moveTo(-500, 0); ctx.lineTo(500, 0);
            let width = (6 - this.animTimer) * 2; 
            ctx.lineWidth = width; ctx.strokeStyle = '#fff'; ctx.shadowColor = '#00eaff'; ctx.shadowBlur = 20;
            ctx.globalAlpha = (6 - this.animTimer) / 5; ctx.stroke();
            ctx.restore(); return;
        }
        ctx.restore();
    }
}

/** INPUT SYSTEM (v17) */
const InputSystem = {
    heldKeys: new Set(), virtualState: { moveX: 0, crouch: false },
    init() {
        window.addEventListener('keydown', e => { if(e.repeat) return; this.heldKeys.add(e.code); this.processInput('KEY', e.code); this.updateVirtualState(); });
        window.addEventListener('keyup', e => { this.heldKeys.delete(e.code); this.updateVirtualState(); });
    },
    processInput(hwType, hwId) {
        if(!Game.running) return;
        for(let cmd of COMMAND_MANIFEST) {
            for(let trig of cmd.triggers) {
                if(trig.hw === hwType && (trig.code === hwId || trig.id === hwId || trig.dir === hwId)) {
                    let modMatch = true;
                    if(trig.hw === 'KEY') {
                        if(trig.mod && !this.heldKeys.has(trig.mod)) modMatch = false;
                        else if(trig.mod === null && (this.heldKeys.has('KeyA') || this.heldKeys.has('KeyD'))) modMatch = false;
                    }
                    if(modMatch) { ComboEngine.push(cmd.id, `${hwType}:${hwId.replace('Key','')}`); return; }
                }
            }
        }
    },
    updateVirtualState() {
        let vx = 0; let down = false;
        if(this.heldKeys.has('KeyA')) vx -= 1; if(this.heldKeys.has('KeyD')) vx += 1; if(this.heldKeys.has('KeyS')) down = true;
        if(TouchInput.stick.x < -0.3) vx = -1; if(TouchInput.stick.x > 0.3) vx = 1; if(TouchInput.currentZone === 6) down = true; 
        this.virtualState.moveX = vx; this.virtualState.crouch = down;
    }
};

const TouchInput = {
    stick: { x: 0, y: 0 }, currentZone: -1,
    init() {
        const base = document.getElementById('stick-base');
        const thumb = document.getElementById('stick-thumb');
        const slots = [];
        for(let i=0; i<8; i++) {
            let d = document.createElement('div'); d.className = 'joy-slot'; d.style.transform = `rotate(${-i*45}deg) translate(65px)`; base.appendChild(d); slots.push(d);
        }
        const handleStick = (t) => {
            const rect = base.getBoundingClientRect();
            let dx = t.clientX - (rect.left + rect.width/2); let dy = t.clientY - (rect.top + rect.height/2);
            let dist = Math.sqrt(dx*dx+dy*dy); let max = 40; if(dist>max) { dx *= max/dist; dy *= max/dist; }
            thumb.style.transform = `translate(${dx}px, ${dy}px)`;
            this.stick.x = dx/max; this.stick.y = -dy/max; 
            let newZone = -1;
            if(dist > 10) {
                let deg = Math.atan2(-dy, dx) * (180/Math.PI); if(deg < 0) deg += 360;
                newZone = Math.floor((deg + 22.5) / 45) % 8;
            }
            if(newZone !== this.currentZone) {
                slots.forEach(s => s.classList.remove('active'));
                if(newZone !== -1) { slots[newZone].classList.add('active'); this.mapZoneToCommand(newZone); }
                this.currentZone = newZone;
            }
            InputSystem.updateVirtualState();
        };
        const resetStick = (e) => {
            e.preventDefault(); thumb.style.transform = `translate(0,0)`; this.stick.x = 0; this.stick.y = 0; this.currentZone = -1;
            slots.forEach(s => s.classList.remove('active')); InputSystem.updateVirtualState();
        };
        base.addEventListener('touchmove', e => { e.preventDefault(); handleStick(e.changedTouches[0]); });
        base.addEventListener('touchstart', e => { e.preventDefault(); handleStick(e.changedTouches[0]); });
        base.addEventListener('touchend', resetStick);

        const pad = document.getElementById('gesture-pad');
        let gStart = {x:0, y:0, t:0};
        pad.addEventListener('touchstart', e => { gStart = {x:e.changedTouches[0].clientX, y:e.changedTouches[0].clientY, t:Date.now()}; });
        pad.addEventListener('touchend', e => {
            let t = e.changedTouches[0]; let dx = t.clientX - gStart.x; let dy = t.clientY - gStart.y; let dt = Date.now() - gStart.t; let dist = Math.sqrt(dx*dx+dy*dy);
            if(dt < 400) {
                gestureTrails = [];
                let lx1 = (gStart.x - Game.offX) / Game.scale; let ly1 = (gStart.y - Game.offY) / Game.scale;
                if (dist > 20) {
                    let lx2 = (t.clientX - Game.offX) / Game.scale; let ly2 = (t.clientY - Game.offY) / Game.scale;
                    gestureTrails.push(new GestureTrail(lx1, ly1, lx2, ly2, false));
                } else { gestureTrails.push(new GestureTrail(lx1, ly1, lx1, ly1, true)); }
            }
            if(dt > 400) return;
            if(dist < 20) InputSystem.processInput('GESTURE', 'TAP');
            else {
                let deg = Math.atan2(-dy, dx) * (180/Math.PI); if(deg < 0) deg += 360;
                let zone = Math.floor((deg + 22.5) / 45) % 8;
                if (zone === 2) InputSystem.processInput('GESTURE', 'SWIPE_UP');
                if (zone === 6) InputSystem.processInput('GESTURE', 'SWIPE_DOWN');
                if (zone === 0) InputSystem.processInput('GESTURE', 'SWIPE_RIGHT');
                if (zone === 4) InputSystem.processInput('GESTURE', 'SWIPE_LEFT');
            }
        });
    },
    mapZoneToCommand(z) { if(z===0) InputSystem.processInput('STICK', 'RIGHT'); if(z===4) InputSystem.processInput('STICK', 'LEFT'); if(z===6) InputSystem.processInput('STICK', 'DOWN'); }
};

const ComboEngine = {
    buffer: [], timeout: 400, timer: null,
    push(cmdId, source) {
        this.buffer.push({id:cmdId, source:source});
        let executed = this.checkMoves();
        if (!executed) UI.addHistory(cmdId, source, 'raw');
        if(this.buffer.length > 0) { if(this.timer) clearTimeout(this.timer); this.timer = setTimeout(()=> { this.buffer=[]; }, this.timeout); }
    },
    checkMoves() {
        let len = this.buffer.length; if(len===0) return false;
        let last = this.buffer[len-1]; let prev = len>=2 ? this.buffer[len-2] : null;
        if(prev && prev.id === 'CMD_CROUCH' && last.id.startsWith('CMD_DASH')) { this.execute('FLASH SLASH', '‚ö°', last.source); return true; }
        if(last.id.startsWith('CMD_DASH')) { let dir = last.id.endsWith('L') ? -1 : (last.id.endsWith('R') ? 1 : 0); this.execute('DASH', '>>', last.source, {dir}); return true; }
        if(last.id === 'CMD_ATK') { this.execute('ATTACK', '‚öîÔ∏è', last.source); return true; }
        if(last.id === 'CMD_JUMP') { this.execute('JUMP', '‚¨Ü', last.source); return true; }
        if(last.id === 'CMD_ULT') { this.execute('ULTIMATE', '‚≠ï', last.source); return true; }
        return false;
    },
    execute(name, icon, src, params) {
        UI.addHistory(name, src, 'move', icon); UI.showToast(name);
        p1.handleCommand(name, params);
        this.buffer = [];
    }
};

/** GAME ENGINE */
let p1, p2;
const Game = {
    running: false, logicW: 1000, logicH: 600, scale: 1, offX: 0, offY: 0,
    timeScale: 1.0, shake: 0, flash: 0, darkOverlay: 0,
    
    init() {
        this.cvs = document.getElementById('canvas'); this.ctx = this.cvs.getContext('2d');
        window.addEventListener('resize', ()=>this.fitScreen());
        this.fitScreen();
        p1 = new Fighter(200, '#00eaff', false); p2 = new Fighter(800, '#ff0055', true);
        this.running = true; this.loop();
    },
    fitScreen() {
        let winW=window.innerWidth, winH=window.innerHeight;
        const dpr = window.devicePixelRatio || 1;
        this.cvs.width=winW*dpr; this.cvs.height=winH*dpr;
        this.cvs.style.width=winW+'px'; this.cvs.style.height=winH+'px';
        this.scale = Math.min(winW/this.logicW, winH/this.logicH);
        this.offX = (winW - this.logicW*this.scale)/2; this.offY = (winH - this.logicH*this.scale)/2;
        this.ctx.setTransform(dpr,0,0,dpr,0,0);
    },
    loop() {
        if(!this.running) { requestAnimationFrame(()=>this.loop()); return; }
        let ctx = this.ctx;
        
        // Updates
        p1.update(1, p2); p2.update(1, p1);
        
        // Camera Calc
        let cam = {x:0, y:0, zoom:1};
        let ultUser = (p1.state.startsWith('ult') && p1.state!=='ult_cast') ? p1 : (p2.state.startsWith('ult') && p2.state!=='ult_cast') ? p2 : null;
        let minX = Math.min(p1.x, p2.x), maxX = Math.max(p1.x+p1.w, p2.x+p2.w);
        let minY = Math.min(p1.y, p2.y), maxY = Math.max(p1.y+p1.h, p2.y+p2.h);
        let centerX = (minX + maxX) / 2, centerY = (minY + maxY) / 2;
        
        if(ultUser) {
            if(ultUser.state === 'ult_slash') {
                let victim = ultUser===p1?p2:p1;
                cam.x = (victim.x+victim.w/2) - this.logicW/2; cam.y = victim.y+victim.h/2; cam.zoom = 1.3;
            } else {
                cam.x = centerX - this.logicW/2; cam.y = centerY;
                let width = (maxX-minX) + 300; cam.zoom = Math.min(Math.max((this.logicW*0.85)/width, 0.7), 1.5);
            }
        } else {
            cam.x = centerX - this.logicW/2; cam.y = centerY;
            let zoomX = this.logicW / ((maxX-minX) + 600); let zoomY = this.logicH / ((maxY-minY) + 400);
            cam.zoom = Math.min(Math.max(Math.min(zoomX, zoomY), 0.6), 1.3);
        }
        
        // Render
        ctx.fillStyle = '#111'; ctx.fillRect(0,0, window.innerWidth, window.innerHeight); // Clear Screen
        
        ctx.save();
        ctx.translate(this.offX, this.offY); ctx.scale(this.scale, this.scale); // Viewport Fit
        
        // Shake
        let dx = (Math.random()-0.5)*this.shake, dy = (Math.random()-0.5)*this.shake;
        if(this.shake>0) this.shake *= 0.9;
        
        ctx.save(); // Camera Transform Start
        ctx.translate(this.logicW/2, this.logicH/2); ctx.scale(cam.zoom, cam.zoom);
        ctx.translate(-this.logicW/2 - cam.x + dx, -cam.y + dy);
        
        // BG
        ctx.fillStyle = '#111';
        for(let i=-5; i<15; i++) {
            let h = 300 + Math.sin(i*132)*100;
            ctx.fillRect(i*200 - (cam.x*0.2), this.logicH-100-h, 120, h);
            ctx.fillStyle = i%3==0 ? '#222' : (i%2==0 ? '#301111' : '#113030');
            ctx.fillRect(i*200 - (cam.x*0.2) + 10, this.logicH-100-h+20, 100, 10);
            ctx.fillStyle = '#111';
        }
        ctx.fillStyle = '#0a0a0a'; ctx.fillRect(-1000, this.logicH-100, this.logicW+2000, 400);
        ctx.strokeStyle = '#00eaff'; ctx.lineWidth = 2; ctx.globalAlpha = 0.3; ctx.beginPath(); ctx.moveTo(-1000, this.logicH-100); ctx.lineTo(this.logicW+2000, this.logicH-100); ctx.stroke(); ctx.globalAlpha = 1;
        
        ctx.fillStyle = '#333'; ctx.strokeStyle = '#00eaff'; ctx.lineWidth = 2;
        for(let p of platforms) {
            ctx.fillRect(p.x, p.y, p.w, p.h); ctx.strokeRect(p.x, p.y, p.w, p.h);
            ctx.save(); ctx.shadowColor = '#00eaff'; ctx.shadowBlur = 10; ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x+p.w, p.y); ctx.stroke(); ctx.restore();
        }
        
        if(this.darkOverlay > 0) { ctx.fillStyle = `rgba(0,0,0,${this.darkOverlay})`; ctx.fillRect(cam.x - 1000, -1000, this.logicW+2000, this.logicH+2000); }
        
        for(let i=afterimages.length-1; i>=0; i--) { afterimages[i].update(); afterimages[i].draw(ctx); if(afterimages[i].life <= 0) afterimages.splice(i, 1); }
        p1.draw(ctx); p2.draw(ctx);
        for(let i=lightningTrails.length-1; i>=0; i--) { lightningTrails[i].draw(ctx); if(lightningTrails[i].timer<=0) lightningTrails.splice(i,1); }
        if(slashLines.length > 0) {
            ctx.save(); ctx.shadowBlur = 10; ctx.shadowColor = '#fff'; ctx.strokeStyle = '#fff'; ctx.lineWidth = 3;
            for(let i=slashLines.length-1; i>=0; i--) {
                let line = slashLines[i]; if(line.delay > 0) { line.delay -= 1; continue; }
                line.life--; ctx.globalAlpha = line.life / 10; ctx.beginPath();
                let halfLen = line.len / 2; let cx = Math.cos(line.angle), cy = Math.sin(line.angle);
                ctx.moveTo(line.x - cx*halfLen, line.y - cy*halfLen); ctx.lineTo(line.x + cx*halfLen, line.y + cy*halfLen); ctx.stroke();
                if(line.life <= 0) slashLines.splice(i, 1);
            }
            ctx.restore();
        }
        for(let i=damageTexts.length-1; i>=0; i--) { damageTexts[i].update(); damageTexts[i].draw(ctx); if(damageTexts[i].life <= 0) damageTexts.splice(i, 1); }
        for(let i=particles.length-1; i>=0; i--) { particles[i].update(); particles[i].draw(ctx); if(particles[i].life<=0) particles.splice(i,1); }
        
        ctx.restore(); // Camera Restore

        // UI Layer (Logic Screen Space)
        for(let i=gestureTrails.length-1; i>=0; i--) { gestureTrails[i].draw(ctx); if(gestureTrails[i].life <= 0) gestureTrails.splice(i,1); }
        if(this.flash > 0) { ctx.fillStyle = `rgba(255,255,255,${this.flash/10})`; ctx.fillRect(0,0,this.logicW,this.logicH); this.flash--; }

        ctx.restore(); // Viewport Restore

        // DOM UI Updates
        document.getElementById('p1-hp').style.width = (p1.hp/p1.maxHp*100)+'%';
        document.getElementById('p1-mp').style.width = p1.mp+'%';
        document.getElementById('p2-hp').style.width = (p2.hp/p2.maxHp*100)+'%';
        document.getElementById('p2-mp').style.width = p2.mp+'%';

        requestAnimationFrame(()=>this.loop());
    }
};

const UI = {
    box: document.getElementById('ui-history'), toast: document.getElementById('ui-log'),
    addHistory(cmd, src, type, iconOvr) {
        let div = document.createElement('div'); div.className = `hist-item type-${type}`;
        let meta = COMMAND_MANIFEST.find(c=>c.id===cmd)||{icon:'?',id:cmd};
        let name = I18N.t(cmd); if(!name || name===cmd) name = I18N.t(cmd.replace('CMD_',''));
        let [hw, id] = src.split(':'); let srcText = `${I18N.t(hw)}:${id}`;
        div.innerHTML = `<div class="hist-left"><span class="icon">${iconOvr||meta.icon}</span><span class="name">${name}</span></div><span class="src">${srcText}</span>`;
        this.box.insertBefore(div, this.box.firstChild); if(this.box.children.length > 8) this.box.lastChild.remove();
    },
    showToast(msg) {
        let text = I18N.t(msg); this.toast.innerHTML = `<div class="log-msg">${text}</div>`;
        setTimeout(()=>{ if(this.toast.firstChild) this.toast.firstChild.style.opacity=1; }, 10);
        setTimeout(()=>{ if(this.toast.firstChild) this.toast.firstChild.remove(); }, 1000);
    }
};

function endGame(result) {
    if(!Game.running) return;
    Game.timeScale = 0.1;
    setTimeout(() => { 
        Game.running = false; 
        const overlay = document.getElementById('game-over-overlay');
        const title = document.getElementById('result-title');
        overlay.style.display = 'flex';
        if(result === 'WIN') { title.innerText = "VICTORY"; title.className = "result-title win-text"; } 
        else { title.innerText = "DEFEAT"; title.className = "result-title lose-text"; }
    }, 2500); 
}

// UI Interaction
const modal = document.getElementById('help-modal');
document.getElementById('btn-help').onclick = () => modal.style.display = 'flex';
document.getElementById('btn-close-help').onclick = () => modal.style.display = 'none';
modal.onclick = (e) => { if(e.target===modal) modal.style.display='none'; };
document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.onclick = () => {
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        btn.classList.add('active'); document.getElementById(btn.dataset.tab).classList.add('active');
    };
});
document.getElementById('btn-restart').onclick = () => { document.getElementById('game-over-overlay').style.display = 'none'; Game.init(); };
document.getElementById('btn-start').onclick = async () => {
    try{ await document.documentElement.requestFullscreen(); await screen.orientation.lock('landscape'); }catch(e){}
    AudioSys.init(); document.getElementById('start-overlay').style.display = 'none';
    if('ontouchstart' in window || navigator.maxTouchPoints > 0) document.getElementById('controls-layer').style.display = 'block';
    I18N.init(); InputSystem.init(); TouchInput.init(); Game.init();
};
</script>
</body>
</html>