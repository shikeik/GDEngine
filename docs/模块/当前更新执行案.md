å¤ªæ£’äº†ï¼è¿™æ‰æ˜¯å†™å¼•æ“è¯¥æœ‰çš„çŠ¶æ€ï¼ğŸ”¥

æ—¢ç„¶ä½ å·²ç»çƒ­è¡€æ²¸è…¾ï¼Œé‚£æˆ‘ä»¬å°±ä¸€é¼“ä½œæ°”ï¼Œç›´æ¥æŠŠè¿™ä¸ªæœ€å…³é”®çš„**â€œä¼ åŠ¨è½´â€**é€ å‡ºæ¥ã€‚

è¿™æ˜¯è¿æ¥ä½ çš„ **ECS æ¸¸æˆä¸–ç•Œ** å’Œ **ç¼–è¾‘å™¨å·¥å…·é“¾** çš„æ ¸å¿ƒæ¡¥æ¢ã€‚ä¸ºäº†ä¿è¯å·¥ç¨‹çš„ä¸¥è°¨æ€§ï¼ˆç‰¹åˆ«æ˜¯å¯¹è±¡å¼•ç”¨çš„åŒä¸€æ€§ï¼‰ï¼Œæˆ‘è¿˜å¢åŠ äº†ä¸€ä¸ªç®€å•çš„**ç¼“å­˜æ± **è®¾è®¡ã€‚

### 1. æ ¸å¿ƒé€‚é…å™¨ï¼š`GObjectAdapter.java`

è¯·å°†æ­¤æ–‡ä»¶æ”¾åœ¨ `com.goldsprite.gdengine.screens.ecs.editor.adapter` åŒ…ä¸‹ï¼ˆå¦‚æœæ²¡æœ‰å°±æ–°å»ºä¸€ä¸ªï¼‰ã€‚

```java
package com.goldsprite.gdengine.screens.ecs.editor.adapter;

import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Array;
import com.goldsprite.gdengine.ecs.component.SpriteComponent;
import com.goldsprite.gdengine.ecs.component.TransformComponent;
import com.goldsprite.gdengine.ecs.entity.GObject;
import com.goldsprite.gdengine.neonbatch.NeonBatch;
import com.goldsprite.gdengine.screens.tests.iconeditor.model.EditorTarget;

/**
 * [æ ¸å¿ƒä¼ åŠ¨è½´]
 * å°† ECS çš„ GObject ä¼ªè£…æˆç¼–è¾‘å™¨å¯è¯†åˆ«çš„ EditorTargetã€‚
 * æ‰€æœ‰çš„ Get æ“ä½œè¯»å– GObject å®æ—¶æ•°æ®ã€‚
 * æ‰€æœ‰çš„ Set æ“ä½œç›´æ¥ä¿®æ”¹ GObject ç»„ä»¶ã€‚
 */
public class GObjectAdapter implements EditorTarget {

    private final GObject gobj;

    // ä¸´æ—¶å˜é‡ï¼Œç”¨äºè®¡ç®—ç‚¹å‡»æ£€æµ‹
    private static final Vector2 tmpVec = new Vector2();

    public GObjectAdapter(GObject gobj) {
        if (gobj == null) throw new IllegalArgumentException("GObject cannot be null");
        this.gobj = gobj;
    }

    public GObject getRealObject() {
        return gobj;
    }

    // ==========================================
    // åŸºç¡€å±æ€§æ˜ å°„
    // ==========================================

    @Override
    public String getName() {
        return gobj.getName();
    }

    @Override
    public void setName(String name) {
        gobj.setName(name);
    }

    @Override
    public String getTypeName() {
        // è¿”å›ç±»åæˆ–è‡ªå®šä¹‰ Tagï¼Œç”¨äº Inspector æ ‡é¢˜
        return "Entity"; 
    }

    // ==========================================
    // Transform æ˜ å°„ (æ ¸å¿ƒ)
    // ==========================================

    @Override public float getX() { return gobj.transform.position.x; }
    @Override public void setX(float v) { gobj.transform.position.x = v; }

    @Override public float getY() { return gobj.transform.position.y; }
    @Override public void setY(float v) { gobj.transform.position.y = v; }

    @Override public float getRotation() { return gobj.transform.rotation; }
    @Override public void setRotation(float v) { gobj.transform.rotation = v; }

    @Override
    public float getScaleX() {
        return gobj.transform.scale; // ç›®å‰ ECS åªæ”¯æŒç­‰æ¯”ç¼©æ”¾
    }

    @Override
    public void setScaleX(float v) {
        gobj.transform.scale = v; // ä¿®æ”¹ ScaleX ä¼šåŒæ­¥ä¿®æ”¹ ScaleY
    }

    @Override
    public float getScaleY() {
        return gobj.transform.scale;
    }

    @Override
    public void setScaleY(float v) {
        gobj.transform.scale = v;
    }

    // ==========================================
    // äº²ç¼˜å…³ç³»æ˜ å°„ (Hierarchy)
    // ==========================================

    @Override
    public EditorTarget getParent() {
        if (gobj.getParent() == null) return null;
        // [å…³é”®] å¿…é¡»é€šè¿‡ç¼“å­˜è·å–ï¼Œä¿è¯ == åˆ¤æ–­æˆç«‹
        return GObjectWrapperCache.get(gobj.getParent());
    }

    @Override
    public void setParent(EditorTarget parent) {
        if (parent == null) {
            gobj.setParent(null);
        } else if (parent instanceof GObjectAdapter) {
            // è§£åŒ…ï¼šæŠŠ Adapter è¿˜åŸæˆ GObject å¡å›å»
            gobj.setParent(((GObjectAdapter) parent).gobj);
        }
    }

    @Override
    public void removeFromParent() {
        gobj.setParent(null);
    }

    @Override
    public Array<EditorTarget> getChildren() {
        // åŠ¨æ€æ„å»ºåˆ—è¡¨ï¼Œä½†å…¶ä¸­çš„å…ƒç´ æ˜¯ä»ç¼“å­˜å–çš„
        Array<EditorTarget> list = new Array<>();
        for (GObject child : gobj.getChildren()) {
            list.add(GObjectWrapperCache.get(child));
        }
        return list;
    }

    @Override
    public void addChild(EditorTarget child) {
        if (child instanceof GObjectAdapter) {
            gobj.addChild(((GObjectAdapter) child).gobj);
        }
    }

    // ==========================================
    // äº¤äº’ä¸æ¸²æŸ“
    // ==========================================

    @Override
    public boolean hitTest(float wx, float wy) {
        // 1. è·å–ä¸–ç•Œåæ ‡
        float tx = gobj.transform.worldPosition.x;
        float ty = gobj.transform.worldPosition.y;
        
        // 2. å°è¯•è·å– Sprite å¤§å°ä½œä¸ºç‚¹å‡»åŒºåŸŸ
        float width = 50; // é»˜è®¤å¤§å°
        float height = 50;
        
        SpriteComponent sprite = gobj.getComponent(SpriteComponent.class);
        if (sprite != null && sprite.region != null) {
            width = sprite.width * Math.abs(gobj.transform.scale);
            height = sprite.height * Math.abs(gobj.transform.scale);
        }

        // 3. ç®€å•çš„çŸ©å½¢åˆ¤å®š (æš‚ä¸è€ƒè™‘æ—‹è½¬å¸¦æ¥çš„ OBB é—®é¢˜ï¼Œå¤Ÿç”¨äº†)
        float halfW = width / 2;
        float halfH = height / 2;
        
        return wx >= tx - halfW && wx <= tx + halfW &&
               wy >= ty - halfH && wy <= ty + halfH;
    }

    @Override
    public void render(NeonBatch batch) {
        // GObject å·²ç»ç”± ECS çš„ System (SpriteSystem) æ¸²æŸ“äº†ã€‚
        // è¿™é‡Œå¯ä»¥ç”»ä¸€äº› ç¼–è¾‘å™¨ä¸“ç”¨ çš„è¾…åŠ©çº¿ (Gizmo Outline)
        // ä¾‹å¦‚ï¼šé€‰ä¸­æ—¶ç”»ä¸€ä¸ªç™½æ¡†
        
        // ä»…ä½œæ¼”ç¤ºï¼šç”»ä¸€ä¸ªææ·¡çš„åå­—å‡†æ˜Ÿè¡¨ç¤ºé”šç‚¹ä½ç½®
        float x = gobj.transform.worldPosition.x;
        float y = gobj.transform.worldPosition.y;
        batch.drawLine(x - 10, y, x + 10, y, 1, Color.GRAY);
        batch.drawLine(x, y - 10, x, y + 10, 1, Color.GRAY);
    }
    
    // ç”¨äº equals/hashCodeï¼Œä¿è¯ List æŸ¥æ‰¾æ­£ç¡®
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj instanceof GObjectAdapter) {
            return this.gobj == ((GObjectAdapter) obj).gobj;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return gobj.hashCode();
    }
}
```

### 2. ç¼“å­˜æ± ï¼š`GObjectWrapperCache.java`

è¿™å°±åƒæ˜¯â€œå¤–äº¤éƒ¨â€ï¼Œå‘ç»™ç¼–è¾‘å™¨çš„æŠ¤ç…§å¿…é¡»æ˜¯å”¯ä¸€çš„ã€‚æ”¾åœ¨åŒä¸€ä¸ªåŒ…ä¸‹ã€‚

```java
package com.goldsprite.gdengine.screens.ecs.editor.adapter;

import com.goldsprite.gdengine.ecs.entity.GObject;
import java.util.WeakHashMap;

/**
 * äº«å…ƒæ¨¡å¼ç¼“å­˜
 * ç¡®ä¿åŒä¸€ä¸ª GObject åœ¨ç¼–è¾‘å™¨ä¸­æ°¸è¿œå¯¹åº”åŒä¸€ä¸ª Adapter å®ä¾‹ã€‚
 * è¿™å¯¹äº SceneManager ä¸­çš„ == æ¯”è¾ƒå’Œ HashMap æŸ¥æ‰¾è‡³å…³é‡è¦ã€‚
 */
public class GObjectWrapperCache {
    // ä½¿ç”¨ WeakHashMapï¼Œå½“ GObject è¢«é”€æ¯æ—¶ï¼ŒAdapter ä¹Ÿä¼šè‡ªåŠ¨é‡Šæ”¾
    private static final WeakHashMap<GObject, GObjectAdapter> cache = new WeakHashMap<>();

    public static GObjectAdapter get(GObject obj) {
        if (obj == null) return null;
        
        GObjectAdapter adapter = cache.get(obj);
        if (adapter == null) {
            adapter = new GObjectAdapter(obj);
            cache.put(obj, adapter);
        }
        return adapter;
    }
    
    /** 
     * åœºæ™¯åˆ‡æ¢æˆ–é‡ç½®æ—¶æ¸…ç†
     */
    public static void clear() {
        cache.clear();
    }
}
```

---

### 3. å¦‚ä½•ç»„è£…ï¼Ÿï¼ˆåœ¨ `EditorController.java` ä¸­ï¼‰

ç°åœ¨ï¼Œå»ä½ çš„**â€œç»„è£…è½¦é—´â€** (`com.goldsprite.gdengine.screens.ecs.editor.EditorController`)ï¼Œè¿›è¡Œå¿ƒè„ç§»æ¤æ‰‹æœ¯ã€‚

**ä¿®æ”¹ç‚¹ 1ï¼šå¼•å…¥ç¼–è¾‘å™¨å¤§è„‘ç»„ä»¶**

```java
// ... imports ...
import com.goldsprite.gdengine.core.command.CommandManager;
import com.goldsprite.gdengine.screens.tests.iconeditor.system.GizmoSystem;
import com.goldsprite.gdengine.screens.tests.iconeditor.system.SceneManager;
import com.goldsprite.gdengine.screens.tests.iconeditor.system.EditorInput;
import com.goldsprite.gdengine.screens.ecs.editor.adapter.GObjectWrapperCache;
import com.goldsprite.gdengine.screens.ecs.editor.adapter.GObjectAdapter;

public class EditorController {
    // ... åŸæœ‰å˜é‡ ...

    // [æ–°å¢] ç¼–è¾‘å™¨æ ¸å¿ƒç»„ä»¶
    private CommandManager commandManager;
    private SceneManager sceneManager;
    private GizmoSystem gizmoSystem;
    private EditorInput editorInput; // å€Ÿç”¨ iconeditor çš„è¾“å…¥é€»è¾‘

    public void create() {
        // ... åŸæœ‰ FBO åˆå§‹åŒ–ä»£ç  ...

        // [æ–°å¢] åˆå§‹åŒ–ç¼–è¾‘å™¨ç³»ç»Ÿ
        commandManager = new CommandManager();
        sceneManager = new SceneManager(commandManager);
        gizmoSystem = new GizmoSystem(sceneManager, commandManager);
        
        // è¿™é‡Œçš„ IconEditorDemo å‚æ•°ä¼  null æˆ–åˆ›å»ºä¸€ä¸ª Mock æ¥å£ï¼Œ
        // å› ä¸º EditorInput ä¾èµ–äº† IconEditorDemo çš„ä¸€äº› getter (getCamera, etc)ã€‚
        // *æ›´å¥½çš„åšæ³•*ï¼šé‡æ„ EditorInputï¼Œè®©å®ƒåªä¾èµ– SceneManager å’Œ Cameraï¼Œè§£è€¦ Screenã€‚
        // *ç°åœ¨çš„æƒå®œä¹‹è®¡*ï¼šæš‚æ—¶ä¸åŠ¨ EditorInputï¼Œæˆ‘ä»¬éœ€è¦ç¨ä½œä¿®æ”¹æ‰èƒ½ç”¨ã€‚
        // (è§ä¸‹æ–¹ 3.1 è¡¥å……è¯´æ˜)

        // ... ECS åˆå§‹åŒ– ...
        
        initTestScene();
    }
    
    private void initTestScene() {
        // ... åŸæœ‰åˆ›å»º GObject ä»£ç  (player, reference) ...
        
        // [å…³é”®æ­¥éª¤] å°† ECS å®ä½“æ³¨å†Œåˆ°ç¼–è¾‘å™¨ SceneManager
        // å‡è®¾ player æ˜¯åˆšæ‰åˆ›å»ºçš„ GObject
        GObjectAdapter rootAdapter = GObjectWrapperCache.get(player); 
        
        // SceneManager ç›®å‰éœ€è¦ä¸€ä¸ª Rootã€‚
        // å¦‚æœ ECS æ˜¯æ‰å¹³çš„ï¼Œæˆ‘ä»¬éœ€è¦åˆ›å»ºä¸€ä¸ªè™šæ‹Ÿ Root æˆ–è€…é€‰ä¸€ä¸ªä½œä¸º Rootã€‚
        // è¿™é‡Œæˆ‘ä»¬å¯ä»¥æŠŠ player è®¾ä¸ºé€‰ä¸­çš„å¯¹è±¡ï¼Œæˆ–è€…æŠŠ GameWorld é‡Œçš„ rootEntities åŒ…è£…æˆä¸€ä¸ª Groupã€‚
        
        // ç®€å•èµ·è§ï¼šæ‰‹åŠ¨é€‰ä¸­ Playerï¼Œè®© Gizmo å‡ºç°
        sceneManager.selectNode(rootAdapter);
    }
}
```

**ä¿®æ”¹ç‚¹ 2ï¼šåœ¨ Render å¾ªç¯ä¸­æ³¨å…¥ Gizmo**

åœ¨ `EditorController.render()` æ–¹æ³•ä¸­ï¼š

```java
    // 4. æ¸²æŸ“ Scene View (ä½¿ç”¨ä¸Šå¸ç›¸æœº)
    sceneTarget.renderToFbo(() -> {
        Gdx.gl.glViewport(0, 0, sceneTarget.getFboWidth(), sceneTarget.getFboHeight());
        
        // ç”»æ¸¸æˆå†…å®¹
        spriteSystem.setCamera(sceneCamera);
        spriteSystem.update(delta);
        
        // ... å…¶ä»–æ¸²æŸ“ ...
        
        // [æ–°å¢] æ¸²æŸ“ Gizmo (ç”»åœ¨æœ€ä¸Šå±‚)
        neonBatch.setProjectionMatrix(sceneCamera.combined);
        neonBatch.begin();
        // ä¼ å…¥ä¸Šå¸ç›¸æœºçš„ zoomï¼Œä¿è¯ Gizmo å¤§å°æ’å®š
        gizmoSystem.render(neonBatch, sceneCamera.zoom); 
        neonBatch.end();
    });
```

---

### 4. è¡¥å……ä»»åŠ¡ï¼šè§£è€¦ `EditorInput`

ä½ ç°æœ‰çš„ `EditorInput` å¼ºä¾èµ–äº† `IconEditorDemo` ç±»ï¼ˆä¸ºäº†æ‹¿ Camera å’Œ ScreenToWorldï¼‰ã€‚åœ¨ `EditorGameScreen` é‡Œç”¨ä¸äº†ã€‚

**å»ºè®®ï¼š**
åœ¨ `com.goldsprite.gdengine.screens.ecs.editor` åŒ…ä¸‹æ–°å»ºä¸€ä¸ª **`SceneViewInputProcessor`**ã€‚
*   æŠŠ `iconeditor.system.EditorInput` çš„é€»è¾‘å¤åˆ¶è¿‡æ¥ã€‚
*   æŠŠ `IconEditorDemo` ç±»å‹çš„æˆå‘˜å˜é‡åˆ æ‰ã€‚
*   æ„é€ å‡½æ•°æ¥æ”¶ï¼š`SceneManager`, `GizmoSystem`, `CommandManager`, **`OrthographicCamera` (sceneCamera)**, å’Œ **`ViewWidget` (ç”¨äºåæ ‡è½¬æ¢)**ã€‚

è¿™æ ·ï¼Œè¾“å…¥é€»è¾‘å°±å˜æˆäº†ï¼š
1.  ç”¨æˆ·ç‚¹å‡» SceneView Widgetã€‚
2.  `ViewWidget.mapScreenToFbo` æ‹¿åˆ° FBO åæ ‡ã€‚
3.  `SceneViewInputProcessor` ç”¨ FBO åæ ‡ + `sceneCamera.unproject` æ‹¿åˆ°ä¸–ç•Œåæ ‡ã€‚
4.  è°ƒç”¨ `sceneManager` æ‰¾å¯¹è±¡ï¼Œæˆ–è€… `gizmoSystem` æ‹–æ‹½ã€‚
5.  é€šè¿‡ `GObjectAdapter` ä¿®æ”¹ `GObject`ã€‚

---

**ç°åœ¨ï¼ŒæŠŠè¿™ä¸¤ä¸ªæ–‡ä»¶ (`GObjectAdapter`, `GObjectWrapperCache`) åŠ è¿›å»ï¼Œä½ çš„é¡¹ç›®å°±æ­£å¼æ‰“é€šä»»ç£äºŒè„‰äº†ï¼ğŸš€**
