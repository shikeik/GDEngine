plugins {
	id 'java-library'
	id 'maven-publish'
}

[compileJava, compileTestJava]*.options*.encoding = 'UTF-8'
eclipse.project.name = appName + '-core'

group = 'com.goldsprite.solofight.core'
version = '0.1.0'

java {
	withJavadocJar()
}

dependencies {
	api "com.badlogicgames.gdx:gdx:$gdxVersion"
	api "com.badlogicgames.gdx:gdx-freetype:$gdxVersion"
	api "com.badlogicgames.gdx:gdx-tools:$gdxVersion"
	api "com.kotcrab.vis:vis-ui:$visUIVersion"
}

publishing {
	publications {
		mavenJava(MavenPublication) {
			from components.java
		}
	}
}

tasks.withType(JavaCompile).configureEach {
	// 用于抑制java构建版本过时警告
	options.compilerArgs << "-Xlint:-options"
}

tasks.javadoc {
	// 配置 Javadoc 的额外选项
	options {
		// 设置语言版本
		source = '8'
		// 配置字符编码
		encoding = 'UTF-8'
		// 取消严格注释
		options.addStringOption('Xdoclint:none', '-quiet')
		// 添加文档标题
		docTitle = 'My Project API Documentation'
		// 显示所有成员，包括私有
		addBooleanOption('private', true)
		// 包含作者和版本信息
		addBooleanOption('author', true)
		addBooleanOption('version', true)
	}
}
// 在构建过程中执行该任务
build.dependsOn javadoc

//自动同步版本文件
def projectPackage = project.projectPackage//获取项目包名
tasks.register('generateBuildConfig') {
	def packagePath = projectPackage.replace('.', '/')//处理为包路径
	def versionFile = file("$projectDir/src/main/java/${packagePath}/BuildConfig.java")//创建配置文件
	versionFile.parentFile.mkdirs()//创建前置所有目录
	//写入数据
	versionFile.text = """package $projectPackage;
public class BuildConfig {
	public static final String PROJECT_NAME = "${rootProject.name}";
	public static final String DEV_VERSION = "${project.projectVersion}";
	public static final String JDK_VERSION = "${project.jdkVersion}";
}"""
	println "Updated BuildConfig version to ${projectVersion}"
}
compileJava.dependsOn(generateBuildConfig)

//更新README项目版本
tasks.register('updateReadmeVersion') {
	//不需要doLast因为修改项目版本号后立即刷新gradle配置就顺势更新了
//	doLast {
	def readmeFile = file("$rootProject.projectDir/README.md")
	if (!readmeFile.exists() || !project.hasProperty("projectVersion")) return

	def content = readmeFile.getText('UTF-8')
	def projectVersion = project.projectVersion
	// 使用正则表达式匹配并替换版本号
	def updatedContent = content.replaceFirst(/^(# $rootProject.name.*V)(.*)/) {
		all, prefix, oldVersion ->
			"${prefix}${projectVersion}"
	}
	readmeFile.write(updatedContent, 'UTF-8')
	println "Updated README.md version to ${projectVersion}"
//	}
}
compileJava.dependsOn(updateReadmeVersion)

// 引擎任务==================================================
// 1. 定义白名单
def exposedLibs = ["gdx", "gdx-tools", "gdx-freetype", "vis-ui"]
// 路径: assets/engine/libs
def assetsLibsDir = file("${project.rootDir}/assets/engine/libs/")

// 第三方库打包任务
tasks.register('copyEngineLibs', Copy) {
	group = "gdengine"
	description = "复制第三方包到 assets/engine/libs"
	from configurations.compileClasspath
	into assetsLibsDir
	include { details ->
		def name = details.file.name
		if (name.contains("natives") || name.contains("sources")) return false
		return exposedLibs.any { key -> name.matches(/^$key-\d+.*\.jar$/) }
	}
	duplicatesStrategy = DuplicatesStrategy.INCLUDE
}

// 引擎核心库打包任务
tasks.register('packageEngineCore', Jar) {
	outputs.upToDateWhen { false }

	// [重要] 只取编译后的 class，不取 resources，避免隐式依赖
	from sourceSets.main.java.classesDirectory
	// 显式依赖编译
	dependsOn compileJava
	dependsOn javadocJar

	archiveFileName = "gdengine.jar"
	destinationDirectory = assetsLibsDir
	exclude "**/*.html", "**/*.gwt.xml"

	// [新增操作] 复制 Javadoc Jar 到引擎目录
    doLast {
        // 1. 找到刚才生成的 javadoc jar 文件
        def javadocJarFile = tasks.javadocJar.archiveFile.get().asFile
        // 2. 目标目录
        def targetDir = file("${project.rootDir}/assets/engine/libs/")
        // 3. 执行复制 (重命名为 gdengine-javadoc.jar 以保持命名规范)
        copy {
            from javadocJarFile
            into targetDir
            rename { "gdengine-javadoc.jar" } // 统一叫 gdengine-javadoc.jar，方便脚本项目引用
        }
        println "✅ [Engine] 引擎核心库已打包."
        println "✅ [Engine] 文档库 (Javadoc) 已发布到 assets/engine/libs/gdengine-javadoc.jar"
    }
}
// 注意：这里删除了所有 dependsOn / finalizedBy 代码
// 全部移交 root_build.gradle 统一管理


// [新增] 自动生成引擎类索引任务
// 这是一个编译期黑科技：在打 JAR 包之前，把所有源码类名写进一个小本本里
tasks.register('generateEngineIndex') {
	// 定义输出路径：放在 resources 目录下，这样会被自动打包进 JAR
	def outputDir = file("src/main/resources")
	def indexFile = file("${outputDir}/engine.index")

	// 声明输入输出，支持 Gradle 增量构建 (虽然对于这个任务快得没必要)
	inputs.files(sourceSets.main.allJava)
	outputs.file(indexFile)

	doLast {
		if (!outputDir.exists()) outputDir.mkdirs()

		def classNames = new TreeSet() // 使用 TreeSet 自动排序

		// 遍历 core 模块的所有 Java 源文件
		sourceSets.main.allJava.each { File file ->
			// 过滤掉非 Java 文件和 package-info
			if (file.name.endsWith(".java") && !file.name.equals("package-info.java")) {

				// 计算包名+类名
				// 逻辑：找到 srcDir (例如 src/main/java)，截取后面的路径
				sourceSets.main.java.srcDirs.each { File srcDir ->
					if (file.absolutePath.startsWith(srcDir.absolutePath)) {
						// 截取相对路径: com/goldsprite/gdengine/ecs/component/TransformComponent.java
						def relPath = file.absolutePath.substring(srcDir.absolutePath.length() + 1)

						// 转换为全类名: com.goldsprite.gdengine.ecs.component.TransformComponent
						def className = relPath.replace(File.separator, ".").replace(".java", "")

						classNames.add(className)
					}
				}
			}
		}

		// 写入文件
		indexFile.text = classNames.join("\n")
		println ">>> [AutoIndex] 生成所有引擎类路径到 engine.index, 共 ${classNames.size()} 个类."
	}
}
// [关键] 挂钩到 processResources 任务
// 确保在处理资源（打包前）时执行此任务
processResources.dependsOn(generateEngineIndex)

// 引擎任务==================================================

testing {
	suites {
		// Configure the built-in test suite
		test {
			// Use JUnit4 test framework
			useJUnit('4.13.2')
		}
	}
}
tasks.named('build') {
	dependsOn testing.suites.test // 确保 testing 的测试任务在 build 时执行
}
