<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>v17.3 Prototype: Optimized UI & VFX</title>
    <style>
        /* --- Âü∫Á°ÄÁéØÂ¢É --- */
        body { margin: 0; background: #222; overflow: hidden; font-family: 'Courier New', monospace; user-select: none; touch-action: none; color: #fff; }
        #game-container { position: relative; width: 100vw; height: 100vh; overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; }

        /* --- UI: Á¥ßÂáëÂûãÊåá‰ª§ÂéÜÂè≤ --- */
        #ui-history {
            position: absolute; top: 50px; left: 10px; width: 160px; bottom: 250px;
            pointer-events: none; display: flex; flex-direction: column-reverse;
            gap: 2px; overflow: hidden; max-height: 200px;
        }
        .hist-item {
            background: rgba(0,0,0,0.8); border-left: 3px solid #555;
            padding: 3px 6px; font-size: 10px; color: #ccc;
            display: flex; align-items: center; justify-content: space-between;
            animation: slideIn 0.1s forwards; flex-shrink: 0; height: 20px;
        }
        @keyframes slideIn { from { opacity: 0; transform: translateX(-10px); } to { opacity: 1; transform: translateX(0); } }
        .hist-item.type-move { border-color: #00eaff; background: linear-gradient(90deg, rgba(0,234,255,0.2), transparent); color: #fff; font-weight: bold; }
        .hist-left { display: flex; align-items: center; }
        .icon { width: 14px; text-align: center; margin-right: 4px; font-weight: bold; }
        .src { font-size: 9px; color: #777; }

        /* --- UI: Âá∫ÊãõË°® (ÁæéÂåñÁâà) --- */
        #btn-help {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.5); border: 1px solid #00eaff; color: #00eaff;
            width: 30px; height: 30px; border-radius: 50%; 
            font-weight: bold; cursor: pointer; z-index: 100;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 0 10px rgba(0,234,255,0.2);
        }
        #help-modal {
            position: absolute; inset: 0; background: rgba(0,0,0,0.9); z-index: 200;
            display: none; flex-direction: column; align-items: center; justify-content: center;
            backdrop-filter: blur(5px);
        }
        .help-container {
            width: 90%; max-width: 500px; background: #1a1a1a; 
            border: 1px solid #00eaff; box-shadow: 0 0 20px rgba(0,234,255,0.1);
            display: flex; flex-direction: column;
        }
        .tabs { display: flex; border-bottom: 1px solid #333; }
        .tab-btn {
            flex: 1; padding: 15px; text-align: center; cursor: pointer;
            color: #888; background: #111; font-weight: bold; font-size: 14px;
            transition: 0.2s;
        }
        .tab-btn.active { color: #00eaff; background: #1a1a1a; border-bottom: 2px solid #00eaff; }
        .tab-content { display: none; padding: 20px; min-height: 200px; }
        .tab-content.active { display: block; animation: fadeIn 0.2s; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        
        table { border-collapse: collapse; width: 100%; font-size: 12px; }
        th { color: #00eaff; text-align: left; padding: 8px; border-bottom: 1px solid #333; }
        td { padding: 8px; border-bottom: 1px solid #222; color: #ddd; }
        .close-hint { padding: 15px; text-align: center; color: #555; cursor: pointer; border-top: 1px solid #333; font-size: 10px; }
        .special-move { color: #ffeb3b; font-weight: bold; }

        /* --- UI: Toast --- */
        #ui-log { position: absolute; bottom: 20%; left: 50%; transform: translateX(-50%); text-align: center; pointer-events: none; text-shadow: 0 0 5px #000; }
        .log-msg { font-size: 20px; color: #ffeb3b; font-weight: 900; margin-top: 5px; opacity: 0; transition: opacity 0.5s; }

        /* --- Controls --- */
        #controls-layer { position: absolute; inset: 0; pointer-events: none; }
        .joystick-base {
            position: absolute; bottom: 40px; left: 40px; width: 140px; height: 140px;
            border-radius: 50%; border: 2px solid rgba(255,255,255,0.1);
            background: rgba(0,0,0,0.3); pointer-events: auto;
        }
        .joy-thumb {
            position: absolute; top: 50%; left: 50%; width: 50px; height: 50px;
            margin: -25px; background: rgba(0, 234, 255, 0.5); border-radius: 50%;
            transform: translate(0,0); transition: transform 0.05s;
        }
        .joy-slot {
            position: absolute; width: 6px; height: 6px; background: #666; border-radius: 50%;
            top: 50%; left: 50%; margin: -3px; transform-origin: 0 0;
        }
        .joy-slot.active { background: #00eaff; box-shadow: 0 0 5px #00eaff; transform: scale(1.5); }
        .gesture-zone {
            position: absolute; bottom: 0; right: 0; width: 50%; height: 80%;
            border-left: 1px dashed rgba(255,255,255,0.1); pointer-events: auto;
        }
        .gesture-hint { position: absolute; bottom: 10px; right: 10px; color: #555; font-size: 10px; }

        /* ÂêØÂä®ÈÅÆÁΩ© */
        #start-overlay {
            position: absolute; inset: 0; background: #111; z-index: 999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        #btn-start {
            padding: 15px 40px; font-size: 20px; font-family: 'Courier New'; font-weight: bold;
            background: transparent; color: #00eaff; border: 2px solid #00eaff;
            cursor: pointer; box-shadow: 0 0 15px rgba(0,234,255,0.2);
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="canvas"></canvas>
    
    <div id="btn-help">?</div>
    <div id="ui-history"></div>
    <div id="ui-log"></div>
    
    <!-- Tabbed Modal -->
    <div id="help-modal">
        <div class="help-container">
            <div class="tabs">
                <div class="tab-btn active" data-tab="tab-controls">CONTROLS</div>
                <div class="tab-btn" data-tab="tab-moves">MOVES LIST</div>
            </div>
            
            <!-- Tab 1: Basic Controls -->
            <div id="tab-controls" class="tab-content active">
                <table>
                    <tr><th>ACTION</th><th>KEYBOARD</th><th>TOUCH</th></tr>
                    <tr><td>Move</td><td>W A S D</td><td>Joystick</td></tr>
                    <tr><td>Jump</td><td>K</td><td>Swipe Up</td></tr>
                    <tr><td>Attack</td><td>J</td><td>Tap</td></tr>
                    <tr><td>Ult</td><td>O</td><td>Swipe Down</td></tr>
                </table>
            </div>
            
            <!-- Tab 2: Moves & Combos -->
            <div id="tab-moves" class="tab-content">
                <table>
                    <tr><th>SKILL</th><th>INPUT SEQUENCE</th></tr>
                    <tr><td>Dash (Left)</td><td>Hold A + Press L <br><span style="color:#888">or Swipe Left</span></td></tr>
                    <tr><td>Dash (Right)</td><td>Hold D + Press L <br><span style="color:#888">or Swipe Right</span></td></tr>
                    <tr><td>Dash (Auto)</td><td>Press L (No Direction)</td></tr>
                    <tr><td class="special-move">Flash Slash</td><td>Hold S + Press L <br><span style="color:#888">or Stick Down + Swipe L/R</span></td></tr>
                </table>
            </div>
            
            <div class="close-hint" id="btn-close-help">TAP ANYWHERE TO CLOSE</div>
        </div>
    </div>

    <div id="controls-layer">
        <div class="joystick-base" id="stick-base">
            <div class="joy-thumb" id="stick-thumb"></div>
        </div>
        <div class="gesture-zone" id="gesture-pad">
            <div class="gesture-hint">SWIPE AREA</div>
        </div>
    </div>
</div>

<div id="start-overlay">
    <h1>v17.3 SANDBOX</h1>
    <button id="btn-start">START TEST</button>
</div>

<script>
/** 1. CONFIG: COMMAND MANIFEST **/
const COMMAND_MANIFEST = [
    { id: 'CMD_MOVE_LEFT',  type: 'STATE', icon: '‚¨Ö',  triggers: [{hw:'KEY', code:'KeyA'}, {hw:'STICK', dir:'LEFT'}] },
    { id: 'CMD_MOVE_RIGHT', type: 'STATE', icon: '‚û°',  triggers: [{hw:'KEY', code:'KeyD'}, {hw:'STICK', dir:'RIGHT'}] },
    { id: 'CMD_CROUCH',     type: 'STATE', icon: '‚¨á',  triggers: [{hw:'KEY', code:'KeyS'}, {hw:'STICK', dir:'DOWN'}] },
    
    { id: 'CMD_JUMP',       type: 'TRIG',  icon: '‚¨Ü',  triggers: [{hw:'KEY', code:'KeyK'}, {hw:'GESTURE', id:'SWIPE_UP'}] },
    { id: 'CMD_ATK',        type: 'TRIG',  icon: '‚öîÔ∏è', triggers: [{hw:'KEY', code:'KeyJ'}, {hw:'GESTURE', id:'TAP'}] },
    { id: 'CMD_ULT',        type: 'TRIG',  icon: '‚≠ï',  triggers: [{hw:'KEY', code:'KeyO'}, {hw:'GESTURE', id:'SWIPE_DOWN'}] },
    
    { id: 'CMD_DASH_L', type: 'TRIG', icon: '‚è™', triggers: [{ hw: 'GESTURE', id: 'SWIPE_LEFT' }, { hw: 'KEY', code: 'KeyL', mod: 'KeyA' }] },
    { id: 'CMD_DASH_R', type: 'TRIG', icon: '‚è©', triggers: [{ hw: 'GESTURE', id: 'SWIPE_RIGHT' }, { hw: 'KEY', code: 'KeyL', mod: 'KeyD' }] },
    { id: 'CMD_DASH_AUTO', type: 'TRIG', icon: 'üöÄ', triggers: [{ hw: 'KEY', code: 'KeyL', mod: null }] }
];

/** 2. INPUT SYSTEM **/
const InputSystem = {
    heldKeys: new Set(),
    virtualState: { moveX: 0, crouch: false },
    init() {
        window.addEventListener('keydown', e => {
            if(e.repeat) return;
            this.heldKeys.add(e.code);
            this.processInput('KEY', e.code);
            this.updateVirtualState();
        });
        window.addEventListener('keyup', e => {
            this.heldKeys.delete(e.code);
            this.updateVirtualState();
        });
    },
    processInput(hwType, hwId) {
        for(let cmd of COMMAND_MANIFEST) {
            for(let trig of cmd.triggers) {
                if(trig.hw === hwType && (trig.code === hwId || trig.id === hwId || trig.dir === hwId)) {
                    let modMatch = true;
                    if(trig.hw === 'KEY') {
                        if(trig.mod && !this.heldKeys.has(trig.mod)) modMatch = false;
                        else if(trig.mod === null && (this.heldKeys.has('KeyA') || this.heldKeys.has('KeyD'))) modMatch = false;
                    }
                    if(modMatch) {
                        this.emitCommand(cmd, hwType, hwId);
                        return;
                    }
                }
            }
        }
    },
    emitCommand(cmd, sourceHw, sourceId) {
        // [v17.3] ÂßîÊâò ComboEngine ÂÜ≥ÂÆöÊòØÂê¶ËÆ∞ÂΩïÊó•Âøó
        ComboEngine.push(cmd.id, `${sourceHw}:${sourceId.replace('Key','')}`);
    },
    updateVirtualState() {
        let vx = 0; let down = false;
        if(this.heldKeys.has('KeyA')) vx -= 1;
        if(this.heldKeys.has('KeyD')) vx += 1;
        if(this.heldKeys.has('KeyS')) down = true;
        if(TouchInput.stick.x < -0.3) vx = -1;
        if(TouchInput.stick.x > 0.3) vx = 1;
        if(TouchInput.currentZone === 6) down = true; 
        this.virtualState.moveX = vx;
        this.virtualState.crouch = down;
    }
};

/** 3. TOUCH INPUT (With Gesture Trails) **/
let gestureTrails = []; // Store visuals

class GestureTrail {
    constructor(x1, y1, x2, y2) {
        this.start = {x:x1, y:y1};
        this.end = {x:x2, y:y2};
        this.life = 1.0;
        
        // Calculate perpendicular vector for thickness
        let dx = x2 - x1, dy = y2 - y1;
        let len = Math.sqrt(dx*dx + dy*dy);
        if(len === 0) len = 1;
        this.nx = -dy / len;
        this.ny = dx / len;
    }
    draw(ctx) {
        if(this.life <= 0) return;
        ctx.save();
        ctx.globalAlpha = this.life;
        ctx.fillStyle = '#fff';
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = 10;
        
        // Visual: Start(Small) -> End(Big)
        let wStart = 2; 
        let wEnd = 20; 

        ctx.beginPath();
        // Start Point (Top)
        ctx.moveTo(this.start.x + this.nx*wStart, this.start.y + this.ny*wStart);
        // End Point (Top)
        ctx.lineTo(this.end.x + this.nx*wEnd, this.end.y + this.ny*wEnd);
        // End Point (Bottom)
        ctx.lineTo(this.end.x - this.nx*wEnd, this.end.y - this.ny*wEnd);
        // Start Point (Bottom)
        ctx.lineTo(this.start.x - this.nx*wStart, this.start.y - this.ny*wStart);
        
        ctx.fill();
        ctx.restore();
        
        this.life -= 0.1; // Fade out fast
    }
}

const TouchInput = {
    stick: { x: 0, y: 0 },
    currentZone: -1,
    
    init() {
        // Joystick Logic (Same as v17.2)
        const base = document.getElementById('stick-base');
        const thumb = document.getElementById('stick-thumb');
        const slots = [];
        for(let i=0; i<8; i++) {
            let d = document.createElement('div');
            d.className = 'joy-slot';
            d.style.transform = `rotate(${-i*45}deg) translate(65px)`;
            base.appendChild(d); slots.push(d);
        }
        const handleStick = (t) => {
            const rect = base.getBoundingClientRect();
            let dx = t.clientX - (rect.left + rect.width/2);
            let dy = t.clientY - (rect.top + rect.height/2);
            let dist = Math.sqrt(dx*dx+dy*dy);
            let max = 40;
            if(dist>max) { dx *= max/dist; dy *= max/dist; }
            thumb.style.transform = `translate(${dx}px, ${dy}px)`;
            this.stick.x = dx/max; this.stick.y = -dy/max; 

            let newZone = -1;
            if(dist > 10) {
                let deg = Math.atan2(-dy, dx) * (180/Math.PI);
                if(deg < 0) deg += 360;
                newZone = Math.floor((deg + 22.5) / 45) % 8;
            }
            if(newZone !== this.currentZone) {
                slots.forEach(s => s.classList.remove('active'));
                if(newZone !== -1) {
                    slots[newZone].classList.add('active');
                    this.mapZoneToCommand(newZone);
                }
                this.currentZone = newZone;
            }
            InputSystem.updateVirtualState();
        };
        const resetStick = (e) => {
            e.preventDefault(); thumb.style.transform = `translate(0,0)`;
            this.stick.x = 0; this.stick.y = 0; this.currentZone = -1;
            slots.forEach(s => s.classList.remove('active'));
            InputSystem.updateVirtualState();
        };
        base.addEventListener('touchmove', e => { e.preventDefault(); handleStick(e.changedTouches[0]); });
        base.addEventListener('touchstart', e => { e.preventDefault(); handleStick(e.changedTouches[0]); });
        base.addEventListener('touchend', resetStick);

        // Gesture Logic with Visuals
        const pad = document.getElementById('gesture-pad');
        let gStart = {x:0, y:0, t:0};
        
        pad.addEventListener('touchstart', e => { 
            let t = e.changedTouches[0];
            gStart = {x:t.clientX, y:t.clientY, t:Date.now()}; 
        });
        
        pad.addEventListener('touchend', e => {
            let t = e.changedTouches[0];
            let dx = t.clientX - gStart.x;
            let dy = t.clientY - gStart.y;
            let dt = Date.now() - gStart.t;
            
            // [v17.3] Visual Trail Spawn
            if(dt < 400 && Math.sqrt(dx*dx+dy*dy) > 20) {
                // Convert screen coord to logic space for rendering? 
                // No, render in screen space or convert?
                // Our rendering loop uses logic space (1000x600).
                // We need to inverse project the touch coords.
                // Or simply: Pass Logic Coords to Trail.
                
                // Inverse Camera:
                let lx1 = (gStart.x - Game.offX) / Game.scale;
                let ly1 = (gStart.y - Game.offY) / Game.scale;
                let lx2 = (t.clientX - Game.offX) / Game.scale;
                let ly2 = (t.clientY - Game.offY) / Game.scale;
                
                gestureTrails.push(new GestureTrail(lx1, ly1, lx2, ly2));
            }

            if(dt > 400) return;
            if(Math.abs(dx)<20 && Math.abs(dy)<20) InputSystem.processInput('GESTURE', 'TAP');
            else if(Math.abs(dy)>Math.abs(dx)) InputSystem.processInput('GESTURE', dy<-50?'SWIPE_UP':'SWIPE_DOWN');
            else InputSystem.processInput('GESTURE', dx<-50?'SWIPE_LEFT':'SWIPE_RIGHT');
        });
    },
    mapZoneToCommand(z) {
        if(z===0) InputSystem.processInput('STICK', 'RIGHT');
        if(z===4) InputSystem.processInput('STICK', 'LEFT');
        if(z===6) InputSystem.processInput('STICK', 'DOWN');
    }
};

/** 4. COMBO ENGINE (De-duplicated) **/
const ComboEngine = {
    buffer: [], timeout: 400, timer: null,
    
    push(cmdId, source) {
        this.buffer.push({id:cmdId, source:source});
        
        // [v17.3 Fix] Á´ãÂç≥Ê£ÄÊü•ÊòØÂê¶Ëß¶ÂèëÊãõÂºè
        // Â¶ÇÊûú checkMoves ËøîÂõû true (Ê∂àË¥π‰∫ÜÊåá‰ª§)ÔºåÂàô‰∏çÂÜçËÆ∞ÂΩï Raw Log
        // Â¶ÇÊûúËøîÂõû falseÔºåËØ¥ÊòéÊåá‰ª§ËøòÂú® buffer ÈáåÁ≠âÂæÖÔºåÂàôËÆ∞ÂΩï Raw Log
        
        let executed = this.checkMoves();
        
        if (!executed) {
            UI.addHistory(cmdId, source, 'raw');
        }
        
        // Âè™ÊúâÂΩì buffer ÈáåËøòÊúâ‰∏úË•øÊó∂ÊâçÈáçÁΩÆ timer
        if(this.buffer.length > 0) {
            if(this.timer) clearTimeout(this.timer);
            this.timer = setTimeout(()=> { this.buffer=[]; }, this.timeout);
        }
    },
    
    checkMoves() {
        let len = this.buffer.length; if(len===0) return false;
        let last = this.buffer[len-1];
        let prev = len>=2 ? this.buffer[len-2] : null;

        // Flash Slash
        if(prev && prev.id === 'CMD_CROUCH' && last.id.startsWith('CMD_DASH')) {
            this.execute('FLASH SLASH', '‚ö°', last.source); return true;
        }
        // Normal Dash
        if(last.id.startsWith('CMD_DASH')) {
            let dir = last.id.endsWith('L') ? -1 : (last.id.endsWith('R') ? 1 : 0);
            this.execute('DASH', '>>', last.source, {dir}); return true;
        }
        // Instant
        if(last.id === 'CMD_ATK') { this.execute('ATTACK', '‚öîÔ∏è', last.source); return true; }
        if(last.id === 'CMD_JUMP') { this.execute('JUMP', '‚¨Ü', last.source); return true; }
        if(last.id === 'CMD_ULT') { this.execute('ULTIMATE', '‚≠ï', last.source); return true; }
        
        return false;
    },
    
    execute(name, icon, src, params) {
        UI.addHistory(name, src, 'move', icon);
        UI.showToast(name);
        Game.triggerAction(name, params);
        this.buffer = []; // Clear buffer
    }
};

/** 5. GAME & UI **/
const Game = {
    logicW: 1000, logicH: 600, scale: 1, offX: 0, offY: 0,
    player: {x:200, y:400, w:40, h:60, color:'#00eaff', vx:0, vy:0},
    enemy: {x:700, y:400, w:40, h:60, color:'#ff0055'},
    init() {
        this.cvs = document.getElementById('canvas');
        this.ctx = this.cvs.getContext('2d');
        window.addEventListener('resize', ()=>this.fit());
        this.fit(); this.loop();
    },
    fit() {
        let winW=window.innerWidth, winH=window.innerHeight;
        this.cvs.width=winW; this.cvs.height=winH;
        this.scale = Math.min(winW/this.logicW, winH/this.logicH);
        this.offX = (winW - this.logicW*this.scale)/2;
        this.offY = (winH - this.logicH*this.scale)/2;
        this.ctx.setTransform(1,0,0,1,0,0);
    },
    triggerAction(name, p) {
        const pl = this.player;
        if(name==='JUMP') pl.vy = -18;
        if(name==='DASH') {
            let d = p.dir === 0 ? (this.enemy.x>pl.x?1:-1) : p.dir;
            pl.vx = 25*d;
        }
        if(name==='FLASH SLASH') {
            pl.x = this.enemy.x - (100 * (this.enemy.x>pl.x?1:-1));
            pl.vx = 0;
            pl.color = '#fff'; setTimeout(()=>pl.color='#00eaff', 100);
        }
        if(name==='ULTIMATE') this.bgFlash = 10;
    },
    loop() {
        let ctx = this.ctx, p = this.player;
        if(InputSystem.virtualState.moveX) p.vx = InputSystem.virtualState.moveX*6;
        else p.vx *= 0.8;
        p.vy += 0.8; p.x += p.vx; p.y += p.vy;
        if(p.y > 500-p.h) { p.y = 500-p.h; p.vy=0; }
        
        ctx.fillStyle = this.bgFlash > 0 ? '#333' : '#111'; 
        if(this.bgFlash>0) this.bgFlash--;
        ctx.fillRect(0,0, ctx.canvas.width, ctx.canvas.height);
        
        ctx.save();
        ctx.translate(this.offX, this.offY); ctx.scale(this.scale, this.scale);
        
        ctx.fillStyle='#1a1a1a'; ctx.fillRect(0,0,this.logicW,this.logicH);
        ctx.strokeStyle='#555'; ctx.beginPath(); ctx.moveTo(0,500); ctx.lineTo(1000,500); ctx.stroke();
        
        ctx.fillStyle=this.enemy.color; ctx.fillRect(this.enemy.x,this.enemy.y,this.enemy.w,this.enemy.h);
        let ph = InputSystem.virtualState.crouch ? p.h/2 : p.h;
        let py = InputSystem.virtualState.crouch ? p.y+p.h/2 : p.y;
        ctx.fillStyle=p.color; ctx.fillRect(p.x, py, p.w, ph);
        if(InputSystem.virtualState.crouch) { ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.strokeRect(p.x-5,py-5,p.w+10,ph+10); }

        // [v17.3] Draw Gesture Trails
        for(let i=gestureTrails.length-1; i>=0; i--) {
            gestureTrails[i].draw(ctx);
            if(gestureTrails[i].life <= 0) gestureTrails.splice(i,1);
        }

        ctx.restore();
        requestAnimationFrame(()=>this.loop());
    }
};

const UI = {
    box: document.getElementById('ui-history'),
    toast: document.getElementById('ui-log'),
    addHistory(cmd, src, type, iconOvr) {
        let div = document.createElement('div');
        div.className = `hist-item type-${type}`;
        let meta = COMMAND_MANIFEST.find(c=>c.id===cmd)||{icon:'?',id:cmd};
        div.innerHTML = `
            <div class="hist-left"><span class="icon">${iconOvr||meta.icon}</span><span class="name">${cmd.replace(/CMD_|Skill_/g,'')}</span></div>
            <span class="src">${src}</span>
        `;
        this.box.insertBefore(div, this.box.firstChild);
        if(this.box.children.length > 8) this.box.lastChild.remove();
    },
    showToast(msg) {
        this.toast.innerHTML = `<div class="log-msg">${msg}</div>`;
        setTimeout(()=>{ if(this.toast.firstChild) this.toast.firstChild.style.opacity=1; }, 10);
        setTimeout(()=>{ if(this.toast.firstChild) this.toast.firstChild.remove(); }, 1000);
    }
};

// Help Modal & Tabs
const modal = document.getElementById('help-modal');
document.getElementById('btn-help').onclick = () => modal.style.display = 'flex';
document.getElementById('btn-close-help').onclick = () => modal.style.display = 'none';
modal.onclick = (e) => { if(e.target===modal) modal.style.display='none'; };

// Tab Switching
document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.onclick = () => {
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        btn.classList.add('active');
        document.getElementById(btn.dataset.tab).classList.add('active');
    };
});

// Bootstrap
document.getElementById('btn-start').onclick = async () => {
    try{ await document.documentElement.requestFullscreen(); await screen.orientation.lock('landscape'); }catch(e){}
    document.getElementById('start-overlay').style.display='none';
    InputSystem.init(); TouchInput.init(); Game.init();
};
</script>
</body>
</html>