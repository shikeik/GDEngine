<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>v17 Prototype: Input & Combo System</title>
    <style>
        /* --- åŸºç¡€ç¯å¢ƒ --- */
        body { margin: 0; background: #222; overflow: hidden; font-family: 'Courier New', monospace; user-select: none; touch-action: none; color: #fff; }
        #game-container { position: relative; width: 100vw; height: 100vh; overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; }

        /* --- UI: æŒ‡ä»¤å†å² (å·¦ä¾§) --- */
		/* [v17.1 ä¿®æ”¹] è°ƒæ•´å¸ƒå±€é˜²æ­¢é®æŒ¡æ‘‡æ† */
        #ui-history {
            position: absolute; 
            top: 60px; 
            left: 20px; 
            width: 250px; 
            bottom: 250px; /* ç•™å‡ºåº•éƒ¨ç©ºé—´ç»™æ‘‡æ† */
            pointer-events: none; 
            display: flex; flex-direction: column-reverse;
            justify-content: flex-start; gap: 5px;
            overflow: hidden;
        }
        .hist-item {
            background: rgba(0,0,0,0.6); border-left: 4px solid #555;
            padding: 8px; font-size: 12px; position: relative;
            transition: all 0.2s; opacity: 0; transform: translateX(-20px);
            animation: slideIn 0.2s forwards;
        }
        @keyframes slideIn { to { opacity: 1; transform: translateX(0); } }
        
        .hist-item.type-raw { border-color: #888; }
        .hist-item.type-move { border-color: #00eaff; background: linear-gradient(90deg, rgba(0,234,255,0.2), transparent); }
        .hist-item.type-fail { border-color: #ff0055; opacity: 0.5; }

        .icon { display: inline-block; width: 20px; text-align: center; font-weight: bold; margin-right: 5px; }
        .cmd-name { font-weight: bold; font-size: 14px; display: block; }
        .cmd-source { font-size: 10px; color: #aaa; display: block; margin-top: 2px; }

        /* --- UI: å…¨å±€æ—¥å¿— (ä¸­ä¸‹) --- */
        #ui-log {
            position: absolute; bottom: 20%; left: 50%; transform: translateX(-50%);
            text-align: center; pointer-events: none;
            text-shadow: 0 0 5px #000;
        }
        .log-msg {
            font-size: 20px; color: #ffeb3b; font-weight: 900; 
            margin-top: 5px; opacity: 0; transition: opacity 0.5s;
        }

        /* --- UI: è§¦æ‘¸æ§ä»¶ --- */
        #controls-layer { position: absolute; inset: 0; pointer-events: none; }
        
        /* æ‘‡æ† */
        .joystick-base {
            position: absolute; bottom: 40px; left: 40px; width: 140px; height: 140px;
            border-radius: 50%; border: 2px solid rgba(255,255,255,0.1);
            background: rgba(0,0,0,0.3); pointer-events: auto;
        }
        .joy-thumb {
            position: absolute; top: 50%; left: 50%; width: 50px; height: 50px;
            margin: -25px; background: rgba(0, 234, 255, 0.5); border-radius: 50%;
            transform: translate(0,0); transition: transform 0.05s;
        }
        .joy-slot {
            position: absolute; width: 10px; height: 10px; background: #555; border-radius: 50%;
            top: 50%; left: 50%; margin: -5px; transform-origin: 0 0;
        }
        
        /* æ‰‹åŠ¿åŒº */
        .gesture-zone {
            position: absolute; bottom: 0; right: 0; width: 50%; height: 80%;
            border-left: 1px dashed rgba(255,255,255,0.1);
            background: rgba(255,0,0,0.05); pointer-events: auto;
        }
        .gesture-hint {
            position: absolute; bottom: 10px; right: 10px; color: #555; font-size: 10px; text-align: right;
        }
        
        /* è°ƒè¯•ä¿¡æ¯ */
        #debug-info { position: absolute; top: 10px; right: 10px; text-align: right; font-size: 12px; color: #888; }
        /* --- å¯åŠ¨é®ç½© --- */
        #start-overlay {
            position: absolute; inset: 0; background: #111; z-index: 999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        #btn-start {
            padding: 20px 50px; font-size: 24px; font-family: 'Courier New'; font-weight: bold;
            background: transparent; color: #00eaff; border: 2px solid #00eaff;
            cursor: pointer; box-shadow: 0 0 15px rgba(0,234,255,0.2);
            transition: 0.2s;
        }
        #btn-start:active { background: #00eaff; color: #000; }
        h1 { font-size: 40px; color: #fff; margin-bottom: 30px; text-shadow: 0 0 10px #fff; }
    </style>
</head>
<body>

<div id="start-overlay">
    <h1>v17 SANDBOX</h1>
    <button id="btn-start">START INPUT TEST</button>
</div>

<div id="game-container">
    <canvas id="canvas"></canvas>
    
    <!-- UI -->
    <div id="ui-history"></div>
    <div id="ui-log"></div>
    <div id="debug-info">
        v17 Prototype<br>
        WASD + J(Atk) K(Jump) L(Dash) O(Ult)<br>
        S+L = Flash Slash
    </div>

    <!-- Controls -->
    <div id="controls-layer">
        <div class="joystick-base" id="stick-base">
            <div class="joy-thumb" id="stick-thumb"></div>
            <!-- 8 slots gen by JS -->
        </div>
        <div class="gesture-zone" id="gesture-pad">
            <div class="gesture-hint">SWIPE / TAP HERE</div>
        </div>
    </div>
</div>

<script>
/**
 * =========================================
 * 1. CONFIG: COMMAND MANIFEST (æ•°æ®é©±åŠ¨æ ¸å¿ƒ)
 * =========================================
 */
const COMMAND_MANIFEST = [
    // --- çŠ¶æ€ç±»æŒ‡ä»¤ (æŒç»­ç”Ÿæ•ˆ) ---
    { id: 'CMD_MOVE_LEFT',  type: 'STATE', icon: 'â¬…',  triggers: [{hw:'KEY', code:'KeyA'}, {hw:'STICK', dir:'LEFT'}] },
    { id: 'CMD_MOVE_RIGHT', type: 'STATE', icon: 'â¡',  triggers: [{hw:'KEY', code:'KeyD'}, {hw:'STICK', dir:'RIGHT'}] },
    { id: 'CMD_CROUCH',     type: 'STATE', icon: 'â¬‡',  triggers: [{hw:'KEY', code:'KeyS'}, {hw:'STICK', dir:'DOWN'}] },
    
    // --- åŠ¨ä½œç±»æŒ‡ä»¤ (ä¸€æ¬¡æ€§è§¦å‘) ---
    { id: 'CMD_JUMP',       type: 'TRIG',  icon: 'â¬†',  triggers: [{hw:'KEY', code:'KeyK'}, {hw:'GESTURE', id:'SWIPE_UP'}] },
    { id: 'CMD_ATK',        type: 'TRIG',  icon: 'âš”ï¸', triggers: [{hw:'KEY', code:'KeyJ'}, {hw:'GESTURE', id:'TAP'}] },
    { id: 'CMD_ULT',        type: 'TRIG',  icon: 'â­•',  triggers: [{hw:'KEY', code:'KeyO'}, {hw:'GESTURE', id:'SWIPE_DOWN'}] },
    
    // --- æŠ€èƒ½æŒ‡ä»¤ (ä¸Šä¸‹æ–‡æ•æ„Ÿ) ---
    // 1. å·¦å†²åˆº
    { 
        id: 'CMD_DASH_L', type: 'TRIG', icon: 'âª', 
        triggers: [
            { hw: 'GESTURE', id: 'SWIPE_LEFT' },      // è§¦å±ç›´æ¥å·¦æ»‘
            { hw: 'KEY', code: 'KeyL', mod: 'KeyA' }  // é”®ç›˜ L + æŒ‰ä½A
        ] 
    },
    // 2. å³å†²åˆº
    { 
        id: 'CMD_DASH_R', type: 'TRIG', icon: 'â©', 
        triggers: [
            { hw: 'GESTURE', id: 'SWIPE_RIGHT' },     // è§¦å±ç›´æ¥å³æ»‘
            { hw: 'KEY', code: 'KeyL', mod: 'KeyD' }  // é”®ç›˜ L + æŒ‰ä½D
        ] 
    },
    // 3. è‡ªåŠ¨/å‰å‘å†²åˆº (å½“æ²¡æŒ‰æ–¹å‘é”®æ—¶)
    { 
        id: 'CMD_DASH_AUTO', type: 'TRIG', icon: 'ğŸš€', 
        triggers: [
            { hw: 'KEY', code: 'KeyL', mod: null }    // é”®ç›˜å•æŒ‰ L
        ] 
    }
];

/**
 * =========================================
 * 2. SYSTEM: INPUT PROCESSOR (è¾“å…¥å½’ä¸€åŒ–)
 * =========================================
 */
const InputSystem = {
    heldKeys: new Set(), // å½“å‰æŒ‰ä¸‹çš„ç‰©ç†æŒ‰é”®
    virtualState: {      // è™šæ‹ŸçŠ¶æ€
        moveX: 0,        // -1, 0, 1
        crouch: false
    }, 
    
    init() {
        // Keyboard Listeners
        window.addEventListener('keydown', e => {
            if(e.repeat) return;
            this.heldKeys.add(e.code);
            this.processInput('KEY', e.code);
            this.updateVirtualState();
        });
        window.addEventListener('keyup', e => {
            this.heldKeys.delete(e.code);
            this.updateVirtualState();
        });
        
        // Touch Listeners (Joystick & Gesture) -> setup in UI section
    },

    // æ ¸å¿ƒå¤„ç†å‡½æ•°ï¼šæŸ¥è¡¨åŒ¹é…
    processInput(hwType, hwId) {
        // éå†æ‰€æœ‰å¯èƒ½çš„æŒ‡ä»¤
        for(let cmd of COMMAND_MANIFEST) {
            // éå†è¯¥æŒ‡ä»¤çš„æ‰€æœ‰è§¦å‘æ¡ä»¶
            for(let trig of cmd.triggers) {
                // 1. ç¡¬ä»¶ç±»å‹ä¸IDåŒ¹é…
                if(trig.hw === hwType && (trig.code === hwId || trig.id === hwId || trig.dir === hwId)) {
                    
                    // 2. æ£€æŸ¥ä¿®é¥°é”® (Modifier)
                    let modMatch = true;
                    if(trig.hw === 'KEY') {
                        if(trig.mod) {
                            // å¿…é¡»æŒ‰ä¸‹ä¿®é¥°é”®
                            if(!this.heldKeys.has(trig.mod)) modMatch = false;
                        } else if (trig.mod === null) {
                            // å¿…é¡» *ä¸* æŒ‰ä¸‹ä»»ä½•æ–¹å‘ä¿®é¥°é”® (é’ˆå¯¹ Auto Dash)
                            // è¿™é‡Œç®€åŒ–é€»è¾‘ï¼šå¦‚æœå®šä¹‰äº† mod: nullï¼Œæ„å‘³ç€å®ƒæ˜¯ Default Fallback
                            // ä½†æˆ‘ä»¬éœ€è¦ç¡®ä¿åƒ A+L è¿™æ ·çš„é«˜ä¼˜å…ˆçº§å…ˆè¢«åŒ¹é…ã€‚
                            // åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å¯ä»¥ç®€å•çš„ä¾èµ– manifest çš„é¡ºåºï¼š
                            // å¿…é¡»å…ˆå®šä¹‰æœ‰ mod çš„ï¼Œå†å®šä¹‰ mod null çš„ã€‚
                            // æˆ–è€…ï¼Œåœ¨è¿™é‡Œæ˜¾å¼æ£€æŸ¥ï¼šå¦‚æœå½“å‰æŒ‰ä¸‹äº† A æˆ– Dï¼Œåˆ™ mod:null ä¸åŒ¹é…
                            if(this.heldKeys.has('KeyA') || this.heldKeys.has('KeyD')) modMatch = false;
                        }
                    }

                    if(modMatch) {
                        this.emitCommand(cmd, hwType, hwId);
                        return; // åŒ¹é…åˆ°ä¸€ä¸ªå°±åœæ­¢ï¼Œé¿å… L åŒæ—¶è§¦å‘ Dash_L å’Œ Dash_Auto
                    }
                }
            }
        }
    },

    // å‘å°„è™šæ‹ŸæŒ‡ä»¤ -> ä¼ ç»™ Combo Engine
    emitCommand(cmd, sourceHw, sourceId) {
        ComboEngine.push(cmd.id, `${sourceHw}:${sourceId.replace('Key','')}`);
    },

    // æ›´æ–°æŒç»­æ€§çŠ¶æ€ (Move/Crouch)
    updateVirtualState() {
        // Reset
        let vx = 0;
        let down = false;

        // Keyboard Check
        if(this.heldKeys.has('KeyA')) vx -= 1;
        if(this.heldKeys.has('KeyD')) vx += 1;
        if(this.heldKeys.has('KeyS')) down = true;

        // Joystick Check (åˆå¹¶è§¦å±çŠ¶æ€)
        if(TouchInput.stick.x < -0.3) vx = -1;
        if(TouchInput.stick.x > 0.3) vx = 1;
        if(TouchInput.stick.y < -0.5) down = true; // Yå‘ä¸Šä¸ºæ­£? å¾…ä¼šçœ‹æ‘‡æ†é€»è¾‘

        this.virtualState.moveX = vx;
        this.virtualState.crouch = down;
        
        // [å…³é”®] å¦‚æœçŠ¶æ€å‘ç”Ÿå˜åŒ–ï¼Œä¹Ÿå¯èƒ½è§†ä¸ºä¸€æ¬¡â€œæŒ‡ä»¤è¾“å…¥â€æ¨å…¥ Buffer (ç”¨äº S+L åˆ¤å®š)
        // è¿™é‡Œåšä¸€ä¸ªç®€å•çš„è¾¹ç¼˜æ£€æµ‹
        if(down && !this.lastCrouch) {
            ComboEngine.push('CMD_CROUCH', 'STATE_CHANGE');
        }
        this.lastCrouch = down;
    },
    lastCrouch: false
};

/**
 * =========================================
 * 3. ENGINE: COMBO & MOVE LOGIC (æ“æ‹›ç³»ç»Ÿ)
 * =========================================
 */
const ComboEngine = {
    buffer: [], // { id, time, source }
    timeout: 400, // ms
    timer: null,

    push(cmdId, source) {
        let now = Date.now();
        
        // Push to buffer
        this.buffer.push({ id: cmdId, time: now, source: source });
        
        // åªè¦æœ‰è¾“å…¥ï¼Œå°±æ·»åŠ ä¸€æ¡ Raw Log
        UI.addHistory(cmdId, source, 'raw');

        // Reset Timeout
        if(this.timer) clearTimeout(this.timer);
        this.timer = setTimeout(() => this.resolveBuffer(), this.timeout);

        // Immediate Check (Eager Evaluation)
        this.checkMoves();
    },

    // æ£€æŸ¥æ‹›å¼è¡¨
    checkMoves() {
        if(this.buffer.length === 0) return;

        // è·å–æœ€è¿‘çš„æŒ‡ä»¤åºåˆ—
        let len = this.buffer.length;
        let last = this.buffer[len-1];
        let prev = len >= 2 ? this.buffer[len-2] : null;

        // --- æ‹›å¼ 1: Flash Slash (é—ªåˆ€) ---
        // åºåˆ—: [CROUCH, DASH_*]
        if(prev && prev.id === 'CMD_CROUCH' && last.id.startsWith('CMD_DASH')) {
            this.executeMove('FLASH SLASH', 'âš¡', last.source);
            this.buffer = []; // Clear
            return;
        }

        // --- æ‹›å¼ 2: Directional Dash (å†²åˆº) ---
        // åºåˆ—: [DASH_*] (å•é”®è§¦å‘ï¼Œä½†å¦‚æœæ˜¯é—ªåˆ€çš„ä¸€éƒ¨åˆ†ä¼šè¢«ä¸Šé¢æ‹¦æˆª)
        // è¿™æ˜¯ä¸€ä¸ª tricky çš„åœ°æ–¹ï¼šå¦‚æœæˆ‘æŒ‰ Lï¼Œæˆ‘è¦ç«‹åˆ»å†²åˆºï¼Œè¿˜æ˜¯ç­‰å¾… S+Lï¼Ÿ
        // åŠ¨ä½œæ¸¸æˆä¸­å†²åˆºé€šå¸¸æ˜¯ç«‹åˆ»çš„ã€‚S+L éœ€è¦ S å…ˆæŒ‰ã€‚
        // æ‰€ä»¥ï¼Œå¦‚æœ Buffer åªæœ‰ [DASH]ï¼Œç«‹åˆ»æ‰§è¡Œå†²åˆºã€‚
        if(last.id.startsWith('CMD_DASH')) {
            // éœ€è¦åˆ¤æ–­å‰ä¸€ä¸ªæ˜¯å¦æ˜¯ Crouchï¼Œå¦‚æœæ˜¯ï¼Œå·²ç»åœ¨ä¸Šé¢ return äº†
            // æ‰€ä»¥è¿™é‡Œå°±æ˜¯å•çº¯çš„ Dash
            let dir = last.id === 'CMD_DASH_L' ? -1 : (last.id === 'CMD_DASH_R' ? 1 : 0);
            this.executeMove('DASH', '>>', last.source, { dir: dir });
            this.buffer = [];
            return;
        }

        // --- æ‹›å¼ 3: Attack / Jump / Ult ---
        // è¿™äº›é€šå¸¸æ˜¯ç«‹å³è§¦å‘
        if(last.id === 'CMD_ATK') {
            this.executeMove('ATTACK', 'âš”ï¸', last.source);
            this.buffer = []; return;
        }
        if(last.id === 'CMD_JUMP') {
            this.executeMove('JUMP', 'â¬†', last.source);
            this.buffer = []; return;
        }
        if(last.id === 'CMD_ULT') {
            this.executeMove('ULTIMATE', 'â­•', last.source);
            this.buffer = []; return;
        }
    },

    resolveBuffer() {
        // è¶…æ—¶ç»“ç®—ï¼šé€šå¸¸ç”¨äºæ¸…é™¤é‚£äº›æ²¡èƒ½è¿æˆæ‹›å¼çš„æ®‹ç•™çŠ¶æ€
        if(this.buffer.length > 0) {
            // UI.addHistory('TIMEOUT', '-', 'fail');
            this.buffer = [];
        }
    },

    executeMove(name, icon, source, params={}) {
        // 1. UI Feedback
        UI.addHistory(name, source, 'move', icon);
        UI.showToast(name);
        
        // 2. Game Logic
        Game.triggerAction(name, params);
    }
};

/**
 * =========================================
 * 4. TOUCH INPUT (Joystick & Gesture)
 * =========================================
 */
const TouchInput = {
    stick: { x: 0, y: 0 },
    
    init() {
        // --- Joystick ---
        const base = document.getElementById('stick-base');
        const thumb = document.getElementById('stick-thumb');
        
        // Gen slots visuals
        for(let i=0; i<8; i++) {
            let d = document.createElement('div');
            d.className = 'joy-slot';
            d.style.transform = `rotate(${i*45}deg) translate(65px)`;
            base.appendChild(d);
        }

        const handleStick = (t) => {
            const rect = base.getBoundingClientRect();
            const cx = rect.left + rect.width/2;
            const cy = rect.top + rect.height/2;
            let dx = t.clientX - cx;
            let dy = t.clientY - cy;
            
            // Limit
            let dist = Math.sqrt(dx*dx+dy*dy);
            let max = 40;
            if(dist>max) { dx *= max/dist; dy *= max/dist; }
            
            thumb.style.transform = `translate(${dx}px, ${dy}px)`;
            
            // Normalize
            this.stick.x = dx / max;
            this.stick.y = -dy / max; // Y up is positive in logic, usually
            
            // Map to CMD triggers
            // ç®€å•å¤„ç†ï¼šæ¯å¸§æ›´æ–° InputSystem ä¼šè¯»å– stick.x/y
            // ä½†éœ€è¦è§¦å‘ processInput ä»¥å¤„ç† STATE æŒ‡ä»¤
            if(this.stick.x < -0.5) InputSystem.processInput('STICK', 'LEFT');
            if(this.stick.x > 0.5) InputSystem.processInput('STICK', 'RIGHT');
            if(this.stick.y < -0.5) InputSystem.processInput('STICK', 'DOWN'); // Screen Down is Logic Y negative? Let's fix axis
            // Screen Y down is +, Logic Y down usually -. 
            // My code above: dy is screen delta. if pull down, dy > 0.
            // this.stick.y = -dy/max => pull down -> y negative.
            // Config: triggers: {hw:'STICK', dir:'DOWN'}
            // So if stick.y < -0.5 -> DOWN. Correct.
            
            InputSystem.updateVirtualState();
        };

        base.addEventListener('touchmove', e => { e.preventDefault(); handleStick(e.changedTouches[0]); });
        base.addEventListener('touchend', e => { 
            e.preventDefault(); 
            thumb.style.transform = `translate(0,0)`;
            this.stick.x = 0; this.stick.y = 0;
            InputSystem.updateVirtualState();
        });
        base.addEventListener('touchstart', e => { e.preventDefault(); handleStick(e.changedTouches[0]); });


        // --- Gestures ---
        const pad = document.getElementById('gesture-pad');
        let start = {x:0, y:0, t:0};
        
        pad.addEventListener('touchstart', e => {
            e.preventDefault();
            let t = e.changedTouches[0];
            start = {x: t.clientX, y: t.clientY, t: Date.now()};
        });
        
        pad.addEventListener('touchend', e => {
            e.preventDefault();
            let t = e.changedTouches[0];
            let dx = t.clientX - start.x;
            let dy = t.clientY - start.y;
            let dt = Date.now() - start.t;
            
            if(dt > 400) return; // Too slow
            
            let absX = Math.abs(dx);
            let absY = Math.abs(dy);
            
            if(absX < 20 && absY < 20) {
                InputSystem.processInput('GESTURE', 'TAP');
            } else if (absY > absX) {
                if(dy < -50) InputSystem.processInput('GESTURE', 'SWIPE_UP');
                if(dy > 50) InputSystem.processInput('GESTURE', 'SWIPE_DOWN');
            } else {
                if(dx < -50) InputSystem.processInput('GESTURE', 'SWIPE_LEFT');
                if(dx > 50) InputSystem.processInput('GESTURE', 'SWIPE_RIGHT');
            }
        });
    }
};

/**
 * =========================================
 * 5. MOCK GAME & RENDERER (è§†è§‰éªŒè¯)
 * =========================================
 */
const UI = {
    historyBox: document.getElementById('ui-history'),
    logBox: document.getElementById('ui-log'),
    
    addHistory(cmd, source, type, iconOverride) {
        let div = document.createElement('div');
        div.className = `hist-item type-${type}`;
        
        // Find command meta
        let meta = COMMAND_MANIFEST.find(c => c.id === cmd) || { icon: '?', id: cmd };
        let icon = iconOverride || meta.icon;
        
        div.innerHTML = `
            <span class="icon">${icon}</span>
            <span class="cmd-name">${cmd.replace('CMD_','').replace('Skill_','')}</span>
            <span class="cmd-source">${source}</span>
        `;
        
        // Insert at top
        this.historyBox.insertBefore(div, this.historyBox.firstChild);
        
        // Limit
        if(this.historyBox.children.length > 8) {
            this.historyBox.lastChild.remove();
        }
    },
    
    showToast(msg) {
        let el = document.createElement('div');
        el.className = 'log-msg';
        el.innerText = `EVENT: ${msg}`;
        this.logBox.appendChild(el);
        
        // Anim
        requestAnimationFrame(()=> el.style.opacity = 1);
        setTimeout(() => {
            el.style.opacity = 0;
            setTimeout(()=>el.remove(), 500);
        }, 1000);
    }
};

const Game = {
    // [v17.1] é€»è¾‘åˆ†è¾¨ç‡é…ç½®
    logicW: 1000,
    logicH: 600,
    scale: 1,
    offsetX: 0,
    offsetY: 0,

    player: { x: 200, y: 400, w: 40, h: 60, color: '#00eaff', vx: 0, vy: 0 },
    enemy: { x: 700, y: 400, w: 40, h: 60, color: '#ff0055' },
    
    init() {
        this.cvs = document.getElementById('canvas');
        this.ctx = this.cvs.getContext('2d');
        
        // [v17.1] ç›‘å¬çª—å£å˜åŒ–ï¼ŒåŠ¨æ€é€‚é…
        window.addEventListener('resize', () => this.fitScreen());
        this.fitScreen(); // åˆå§‹é€‚é…
        
        this.loop();
    },
    
    // [v17.1] å±å¹•é€‚é…æ ¸å¿ƒç®—æ³• (Letterbox / Fit)
    fitScreen() {
        const dpr = window.devicePixelRatio || 1;
        const winW = window.innerWidth;
        const winH = window.innerHeight;

        // 1. è®¾ç½®ç‰©ç†åˆ†è¾¨ç‡ (HiDPI)
        this.cvs.width = winW * dpr;
        this.cvs.height = winH * dpr;
        // 2. è®¾ç½® CSS å°ºå¯¸
        this.cvs.style.width = winW + 'px';
        this.cvs.style.height = winH + 'px';
        
        // 3. è®¡ç®—ç¼©æ”¾æ¯” (ä¿æŒçºµæ¨ªæ¯”ï¼Œå…¨éƒ¨æ˜¾ç¤º)
        const scaleX = winW / this.logicW;
        const scaleY = winH / this.logicH;
        this.scale = Math.min(scaleX, scaleY); // å–æœ€å°å€¼ä»¥ç¡®ä¿å®Œæ•´æ˜¾ç¤º
        
        // 4. è®¡ç®—å±…ä¸­åç§»é‡
        this.offsetX = (winW - this.logicW * this.scale) / 2;
        this.offsetY = (winH - this.logicH * this.scale) / 2;
        
        // 5. åº”ç”¨ HiDPI ç¼©æ”¾
        this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    },
    
    triggerAction(moveName, params) {
        const p = this.player;
        if(moveName === 'JUMP') p.vy = -18;
        if(moveName === 'DASH') {
            let dir = params.dir;
            if(dir === 0) dir = this.enemy.x > p.x ? 1 : -1; 
            p.vx = 25 * dir; 
        }
        if(moveName === 'FLASH SLASH') {
            // ç®€å•çš„ç©¿æ¢­æ¼”ç¤º
            let dir = this.enemy.x > p.x ? 1 : -1;
            p.x = this.enemy.x - (100 * dir); 
            p.vx = 0;
            // ç®€å•çš„è§†è§‰åé¦ˆ
            p.color = '#fff'; setTimeout(()=>p.color='#00eaff', 100);
        }
    },
    
    loop() {
        const ctx = this.ctx;
        const p = this.player;
        
        // --- Logic Step ---
        let moveDir = InputSystem.virtualState.moveX;
        
        // ç®€å•çš„åŠ å‡é€Ÿæ‰‹æ„Ÿ
        if(moveDir !== 0) {
            p.vx += moveDir * 2;
            if(p.vx > 8) p.vx = 8;
            if(p.vx < -8) p.vx = -8;
        } else {
            p.vx *= 0.8; // æ‘©æ“¦åŠ›
        }

        p.vy += 0.8; // é‡åŠ›
        p.x += p.vx;
        p.y += p.vy;
        
        // åœ°æ¿ç¢°æ’ (åŸºäºé€»è¾‘åæ ‡ 600 é«˜åº¦)
        const floorY = 500; 
        if(p.y + p.h > floorY) { p.y = floorY - p.h; p.vy = 0; }
        
        // å¢™å£ç¢°æ’
        if(p.x < 0) { p.x = 0; p.vx = 0; }
        if(p.x > this.logicW - p.w) { p.x = this.logicW - p.w; p.vx = 0; }
        
        // --- Render Step ---
        // 1. æ¸…é™¤å…¨å± (é»‘è‰²èƒŒæ™¯)
        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, window.innerWidth, window.innerHeight); // ä½¿ç”¨å±å¹•å°ºå¯¸æ¸…é™¤
        
        // 2. åº”ç”¨ç›¸æœºå˜æ¢ (å±…ä¸­ + ç¼©æ”¾)
        ctx.save();
        ctx.translate(this.offsetX, this.offsetY);
        ctx.scale(this.scale, this.scale);
        
        // 3. ç»˜åˆ¶æ¸¸æˆåŒºåŸŸèƒŒæ™¯ (æ·±ç°è‰²ï¼Œè¡¨ç¤ºæœ‰æ•ˆæ´»åŠ¨åŒº)
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(0, 0, this.logicW, this.logicH);
        
        // ç»˜åˆ¶åœ°æ¿çº¿
        ctx.strokeStyle = '#555'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(0, floorY); ctx.lineTo(this.logicW, floorY); ctx.stroke();

        // ç»˜åˆ¶è¾…åŠ©ç½‘æ ¼ (è°ƒè¯•ç”¨)
        ctx.strokeStyle = '#333'; ctx.lineWidth = 1;
        ctx.beginPath();
        for(let i=0; i<this.logicW; i+=100) { ctx.moveTo(i,0); ctx.lineTo(i, this.logicH); }
        for(let i=0; i<this.logicH; i+=100) { ctx.moveTo(0,i); ctx.lineTo(this.logicW, i); }
        ctx.stroke();

        // Draw Enemy
        ctx.fillStyle = this.enemy.color;
        ctx.fillRect(this.enemy.x, this.enemy.y, this.enemy.w, this.enemy.h);
        ctx.fillStyle = '#fff'; ctx.font = '12px Courier New'; ctx.textAlign = 'center';
        ctx.fillText('ENEMY', this.enemy.x + this.enemy.w/2, this.enemy.y - 10);
        
        // Draw Player
        // Crouch Visual
        let drawH = p.h; 
        let drawY = p.y;
        if(InputSystem.virtualState.crouch) {
            drawH = p.h / 2;
            drawY = p.y + p.h / 2;
            ctx.fillStyle = '#0088aa'; // å˜æš—
        } else {
            ctx.fillStyle = p.color;
        }
        
        ctx.fillRect(p.x, drawY, p.w, drawH);
        
        // Flash Slash Ready Hint (White Box)
        if(InputSystem.virtualState.crouch) {
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; 
            ctx.strokeRect(p.x-5, drawY-5, p.w+10, drawH+10);
        }
        
        // Debug Text (åœ¨æ¸¸æˆä¸–ç•Œå†…)
        ctx.fillStyle = '#666'; ctx.textAlign = 'left';
        ctx.fillText(`LOGIC RES: ${this.logicW}x${this.logicH}`, 20, 30);
        
        ctx.restore(); // ç»“æŸç›¸æœºå˜æ¢
        
        requestAnimationFrame(() => this.loop());
    }
};

// --- BOOTSTRAP ---
document.getElementById('btn-start').addEventListener('click', async () => {
    // 1. å°è¯•å…¨å±
    const docEl = document.documentElement;
    if(docEl.requestFullscreen) await docEl.requestFullscreen();
    else if(docEl.webkitRequestFullscreen) await docEl.webkitRequestFullscreen();
    
    // 2. å°è¯•é”å®šæ¨ªå±
    if(screen.orientation && screen.orientation.lock) {
        try { await screen.orientation.lock('landscape'); } catch(e) { console.log('Lock failed'); }
    }
    
    // 3. éšè—é®ç½©å¹¶å¯åŠ¨
    document.getElementById('start-overlay').style.display = 'none';
    
    InputSystem.init();
    TouchInput.init();
    Game.init();
});

</script>
</body>
</html>