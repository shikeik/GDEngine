<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PHANTOM EDGE: Input System Prototype (v17)</title>
    <style>
        body { margin: 0; background: #111; color: #fff; font-family: 'Courier New', monospace; overflow: hidden; display: flex; }
        
        /* 左侧：模拟游戏区 */
        #game-mockup {
            flex: 2; height: 100vh; position: relative; border-right: 2px solid #333;
            background: radial-gradient(circle at center, #222 0%, #000 100%);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        
        /* 模拟角色 */
        #dummy-player {
            width: 40px; height: 80px; background: #00eaff; 
            box-shadow: 0 0 20px #00eaff; transition: all 0.1s;
            position: relative;
        }
        #dummy-enemy {
            position: absolute; width: 40px; height: 80px; background: #ff0055;
            right: 100px; opacity: 0.5; border: 2px dashed #ff0055;
        }
        #dummy-label { position: absolute; top: -30px; width: 200px; left: -80px; text-align: center; font-size: 12px; color: #aaa; }
        
        /* 状态指示器 */
        .status-panel {
            position: absolute; top: 20px; left: 20px; text-align: left;
        }
        .key-indicator {
            display: inline-block; padding: 5px 10px; margin: 2px;
            border: 1px solid #555; color: #555; border-radius: 4px; font-weight: bold;
        }
        .key-indicator.active { border-color: #00eaff; color: #00eaff; background: rgba(0, 234, 255, 0.1); box-shadow: 0 0 10px rgba(0,234,255,0.2); }

        /* 右侧：搓招时间表 UI */
        #command-history {
            flex: 1; height: 100vh; background: #0a0a0a; 
            display: flex; flex-direction: column;
            border-left: 1px solid #333;
        }
        .history-header {
            padding: 15px; background: #111; border-bottom: 1px solid #333;
            color: #888; font-size: 14px; text-transform: uppercase; letter-spacing: 1px;
        }
        .history-list {
            flex: 1; overflow-y: auto; padding: 10px;
            display: flex; flex-direction: column-reverse; /* 最新在下? 不，通常格斗游戏最新在上，或者由于是log，最新在下。这里采用最新在下 */
            justify-content: flex-end; /* 顶部对齐 */
        }
        
        /* 历史记录条目 */
        .log-entry {
            display: flex; align-items: center; justify-content: space-between;
            padding: 8px 10px; border-bottom: 1px solid #222;
            animation: fadeIn 0.2s ease-out;
        }
        .log-inputs { display: flex; gap: 5px; }
        .log-icon {
            width: 24px; height: 24px; background: #222; color: #aaa;
            display: flex; align-items: center; justify-content: center;
            border-radius: 4px; font-size: 12px; font-weight: bold;
        }
        .log-result {
            font-size: 14px; color: #444; font-style: italic;
        }
        /* 成功搓招样式 */
        .log-entry.combo-success { background: rgba(0, 234, 255, 0.05); }
        .log-entry.combo-success .log-result { color: #00eaff; text-shadow: 0 0 5px rgba(0,234,255,0.5); font-weight: bold; }
        /* 失败/断连样式 */
        .log-entry.combo-fail .log-icon { color: #555; }
        
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* 模拟触摸控件 (仅视觉) */
        #touch-mock { position: absolute; bottom: 20px; left: 20px; opacity: 0.5; pointer-events: none; }
    </style>
</head>
<body>

<div id="game-mockup">
    <div class="status-panel">
        <div>KEYBOARD STATE:</div>
        <div id="key-w" class="key-indicator">W (N/A)</div>
        <div id="key-a" class="key-indicator">A (LEFT)</div>
        <div id="key-s" class="key-indicator">S (DOWN)</div>
        <div id="key-d" class="key-indicator">D (RIGHT)</div>
        <br>
        <div id="key-j" class="key-indicator">J (ATK)</div>
        <div id="key-k" class="key-indicator">K (JUMP)</div>
        <div id="key-l" class="key-indicator">L (DASH)</div>
        <div id="key-o" class="key-indicator">O (ULT)</div>
        <div style="margin-top:10px; font-size:12px; color:#666">
            Enemy is to the RIGHT.<br>
            Combo Window: 0.4s
        </div>
    </div>

    <div id="dummy-player">
        <div id="dummy-label">IDLE</div>
    </div>
    <div id="dummy-enemy"></div>
    
    <div id="touch-mock">Touch Inputs simulated via Mouse Drag</div>
</div>

<div id="command-history">
    <div class="history-header">Input Stream & Command Log</div>
    <div id="history-log" class="history-list">
        <!-- Logs go here -->
    </div>
</div>

<script>
/**
 * v17 INPUT SYSTEM PROTOTYPE
 * 包含：输入监听、缓冲队列、招式匹配、UI可视化
 */

// 1. 常量定义
const KEY_MAP = {
    'a': 'LEFT', 'd': 'RIGHT', 's': 'DOWN', 
    'k': 'JUMP', 'j': 'ATK', 'l': 'DASH', 'o': 'ULT'
};

// 模拟状态
let gameState = {
    facing: 1, // 1 = Right, -1 = Left (Simulated Auto-Face Enemy)
    enemyDir: 1, // Enemy is to the right
    keys: { LEFT:false, RIGHT:false, DOWN:false, JUMP:false, ATK:false, DASH:false, ULT:false }
};

// 2. 搓招处理器 (The Brain)
const CommandProcessor = {
    buffer: [],      // 当前输入的按键序列 [{key: 'DOWN', time: 12345}]
    timeout: null,   // 0.4s 计时器
    windowTime: 400, // ms
    
    // 核心入口：接收原始输入
    receiveInput(inputKey) {
        // 如果是按住类按键(WASD)，只记录状态，但也可能作为搓招起始(如 ↓ -> L)
        // 但根据需求，我们要把它们视为事件序列
        
        // 1. 推入缓冲
        this.buffer.push({ key: inputKey, time: Date.now() });
        this.updateUI_Pending(); // 更新UI显示“正在输入...”
        
        // 2. 重置计时器
        if (this.timeout) clearTimeout(this.timeout);
        this.timeout = setTimeout(() => {
            this.flushBuffer("TIMEOUT"); // 超时强制结算
        }, this.windowTime);

        // 3. 立即尝试匹配 (Eager Matching)
        // 某些招式是“按下即触发”的，不需要等超时，比如 J (攻击)
        // 但如果是 S + L，我们需要看缓冲区里是否有 S (Hold) 和 L (Press)
        this.checkMoves();
    },

    checkMoves() {
        // 获取缓冲区最新的输入
        const lastInput = this.buffer[this.buffer.length - 1];
        
        // 判定逻辑：从后往前看，匹配招式
        // v17 规则：
        // Dash: (L) + (A/D optional)
        // Flash Slash: (L) + (S held or in buffer recently)
        
        if (lastInput.key === 'DASH') {
            // ---> 检查是否触发 闪刀 (Flash Slash)
            // 条件：按住了 S (DOWN) 或者缓冲区前一个是 S
            if (gameState.keys.DOWN || this.wasPressedRecently('DOWN', 200)) {
                this.triggerMove('FLASH_SLASH', ['DOWN', 'DASH']);
                return;
            }
            
            // ---> 检查是否触发 冲刺 (Dash)
            // 判定方向
            let dirStr = "AUTO";
            if (gameState.keys.LEFT) dirStr = "LEFT";
            else if (gameState.keys.RIGHT) dirStr = "RIGHT";
            
            this.triggerMove(`DASH [${dirStr}]`, [dirStr==='AUTO'?'NEUTRAL':dirStr, 'DASH']);
            return;
        }
        
        if (lastInput.key === 'ATK') {
            this.triggerMove('ATTACK', ['ATK']);
            return;
        }
        
        if (lastInput.key === 'JUMP') {
            this.triggerMove('JUMP', ['JUMP']);
            return;
        }

        if (lastInput.key === 'ULT') {
            this.triggerMove('ULTIMATE', ['ULT']);
            return;
        }
        
        // 如果只是按下了 A/S/D，不触发招式，仅保留在 Buffer 中等待后续
        // 除非超时
    },
    
    wasPressedRecently(key, timeWindow) {
        const now = Date.now();
        // 从倒数第二个开始找(倒数第一个是刚按下的L)
        for(let i = this.buffer.length-2; i>=0; i--) {
            if(this.buffer[i].key === key && (now - this.buffer[i].time < timeWindow)) {
                return true;
            }
        }
        return false;
    },

    triggerMove(moveName, consumedInputs) {
        // 1. 结算成功，清除计时器
        if (this.timeout) clearTimeout(this.timeout);
        
        // 2. 记录日志
        Logger.addEntry(this.buffer, moveName, true);
        
        // 3. 视觉反馈
        Visualizer.playAction(moveName);
        
        // 4. 清空缓冲
        this.buffer = [];
    },

    flushBuffer(reason) {
        if (this.buffer.length === 0) return;
        
        // 视为失败/断连/普通移动输入
        // 比如只按了 S，然后松开了，或者超时了
        // 我们把它记录为 "Raw Input"
        let label = "RAW";
        if(this.buffer.length === 1 && ['LEFT','RIGHT','DOWN'].includes(this.buffer[0].key)) {
            label = "MOVE";
        }
        
        Logger.addEntry(this.buffer, label, false);
        this.buffer = [];
    }
};

// 3. UI 日志系统 (Logger)
const Logger = {
    container: document.getElementById('history-log'),
    
    addEntry(inputBuffer, resultText, isSuccess) {
        const row = document.createElement('div');
        row.className = `log-entry ${isSuccess ? 'combo-success' : 'combo-fail'}`;
        
        // 图标序列
        let iconsHtml = '';
        inputBuffer.forEach(item => {
            iconsHtml += `<div class="log-icon">${this.keyToIcon(item.key)}</div>`;
        });
        
        row.innerHTML = `
            <div class="log-inputs">${iconsHtml}</div>
            <div class="log-result">${resultText}</div>
        `;
        
        // 最新在下 (Terminal Style)
        // this.container.appendChild(row); 
        // this.container.scrollTop = this.container.scrollHeight;
        
        // 或者最新在上 (Notification Style) - 用户倾向于搓招时间表，通常最新在上更方便看
        this.container.insertBefore(row, this.container.firstChild);
    },
    
    keyToIcon(key) {
        const map = {
            'LEFT': '←', 'RIGHT': '→', 'DOWN': '↓', 'UP': '↑',
            'ATK': 'J', 'JUMP': 'K', 'DASH': 'L', 'ULT': 'O',
            'NEUTRAL': 'N'
        };
        return map[key] || key;
    },
    
    // 待定：Pending UI
    updatePending() {
        // 可以在这里实现一个半透明的“正在输入”行
    }
};
CommandProcessor.updateUI_Pending = Logger.updatePending;

// 4. 视觉反馈 (Mockup)
const Visualizer = {
    player: document.getElementById('dummy-player'),
    label: document.getElementById('dummy-label'),
    
    playAction(name) {
        this.label.innerText = name;
        this.player.style.transform = 'scale(1.1)';
        this.player.style.filter = 'brightness(1.5)';
        
        if(name.includes('FLASH')) {
            this.player.style.background = '#fff';
            this.player.style.boxShadow = '0 0 50px #fff';
            // 模拟向敌人冲
            let moveDir = gameState.enemyDir; // Flash Slash always towards enemy
            this.player.style.transform = `translateX(${moveDir * 100}px) skewX(${-20*moveDir}deg)`;
        } else if (name.includes('DASH')) {
            this.player.style.background = '#00eaff';
            // 判定方向
            let moveDir = 0;
            if(name.includes('LEFT')) moveDir = -1;
            else if(name.includes('RIGHT')) moveDir = 1;
            else moveDir = gameState.enemyDir; // Auto
            
            this.player.style.transform = `translateX(${moveDir * 50}px)`;
        } else if (name === 'ATTACK') {
            this.player.style.transform = 'translateX(20px)';
        }
        
        setTimeout(() => {
            this.player.style.transform = 'none';
            this.player.style.background = '#00eaff';
            this.player.style.filter = 'none';
            this.player.style.boxShadow = '0 0 20px #00eaff';
            this.label.innerText = 'IDLE';
        }, 200);
    }
};

// 5. 事件监听 (Keyboard)
window.addEventListener('keydown', e => {
    const key = e.key.toLowerCase();
    if (KEY_MAP[key]) {
        const mapped = KEY_MAP[key];
        
        // 状态高亮
        const el = document.getElementById(`key-${key}`);
        if(el) el.classList.add('active');
        
        // 记录按住状态
        if (!gameState.keys[mapped]) {
            gameState.keys[mapped] = true;
            // 只有按下那一刻才送入 Processor
            CommandProcessor.receiveInput(mapped);
        }
    }
});

window.addEventListener('keyup', e => {
    const key = e.key.toLowerCase();
    if (KEY_MAP[key]) {
        const mapped = KEY_MAP[key];
        const el = document.getElementById(`key-${key}`);
        if(el) el.classList.remove('active');
        
        gameState.keys[mapped] = false;
    }
});

// 6. 事件监听 (Touch Simulation for Testing)
// 简单的鼠标模拟：点击左侧区域模拟L，下滑模拟S+L
// 这里只是为了在电脑上测逻辑，实机触屏逻辑在 v17 整合时会完全一致
document.addEventListener('mousedown', () => {
   // Click = Tap = Attack
   // CommandProcessor.receiveInput('ATK');
});

// 初始化日志
Logger.addEntry([], "SYSTEM READY", true);

</script>
</body>
</html>