<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>NEON BLADE: OVERDRIVE (Á©∂ÊûÅËøõÂåñÁâà)</title>
    <style>
        body { margin: 0; background: #050505; overflow: hidden; font-family: 'Segoe UI', sans-serif; user-select: none; }
        canvas { display: block; }
        
        /* UI Â±Ç */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* È°∂ÈÉ® HUD */
        .hud-top { display: flex; justify-content: space-between; padding: 20px 40px; }
        .bar-container { width: 40%; position: relative; }
        .name { color: #fff; font-weight: 900; font-size: 24px; font-style: italic; text-shadow: 0 0 10px currentColor; margin-bottom: 5px; display:flex; justify-content: space-between;}
        
        .hp-track { height: 20px; background: rgba(50,50,50,0.8); transform: skewX(-20deg); border: 2px solid #fff; position: relative; overflow: hidden; }
        .hp-fill { height: 100%; width: 100%; transition: width 0.1s ease-out; position: relative; }
        .hp-fill::after { content:''; position: absolute; top:0; left:0; width:100%; height:50%; background: rgba(255,255,255,0.3); }
        
        .mp-track { height: 10px; background: rgba(0,0,0,0.8); margin-top: 5px; transform: skewX(-20deg); border: 1px solid #555; width: 80%; }
        .mp-fill { height: 100%; width: 0%; background: #00eaff; box-shadow: 0 0 15px #00eaff; transition: width 0.1s; }

        /* P1 Ê†∑Âºè */
        #p1-bar .name { color: #00ff88; }
        #p1-hp { background: #00ff88; box-shadow: 0 0 20px #00ff88; float: right; }
        #p1-mp-track { float: right; }
        
        /* P2 Ê†∑Âºè */
        #p2-bar .name { color: #ff0055; flex-direction: row-reverse; }
        #p2-hp { background: #ff0055; box-shadow: 0 0 20px #ff0055; float: left; }
        
        /* ËøûÂáª‰∏éÊèêÁ§∫ */
        .center-msg { position: absolute; top: 15%; left: 50%; transform: translateX(-50%); text-align: center; }
        .combo-counter { font-size: 60px; font-weight: 900; font-style: italic; color: #ffeb3b; text-shadow: 4px 4px 0 #000; opacity: 0; transition: transform 0.1s; }
        .ko-text { font-size: 120px; color: #fff; text-shadow: 0 0 30px #f00; font-weight: 900; letter-spacing: 10px; display: none; animation: zoomIn 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        
        @keyframes zoomIn { from { transform: scale(3); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        /* ÂºÄÂßã/ÁªìÊùüÈÅÆÁΩ© */
        #overlay { position: absolute; inset: 0; background: rgba(0,0,0,0.85); backdrop-filter: blur(10px); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; pointer-events: auto; }
        h1 { color: #fff; font-size: 60px; margin: 0; text-shadow: 0 0 30px #00eaff; font-style: italic; letter-spacing: -2px; }
        h2 { color: #888; font-size: 20px; margin-top: 10px; margin-bottom: 40px; }
        .key-guide { display: grid; grid-template-columns: 1fr 1fr; gap: 40px; color: #aaa; margin-bottom: 40px; text-align: left; background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px;}
        .key { display: inline-block; background: #333; color: #fff; padding: 2px 8px; border-radius: 4px; font-family: monospace; border-bottom: 2px solid #111; font-weight: bold; margin: 0 4px; }
        
        button { background: transparent; color: #00eaff; border: 2px solid #00eaff; padding: 15px 60px; font-size: 24px; font-weight: bold; cursor: pointer; text-transform: uppercase; letter-spacing: 2px; transition: 0.2s; box-shadow: 0 0 15px rgba(0, 234, 255, 0.2); }
        button:hover { background: #00eaff; color: #000; box-shadow: 0 0 40px rgba(0, 234, 255, 0.6); }

        /* ÁßªÂä®Á´ØËôöÊãüÊåâÈîÆ - ÈªòËÆ§ÈöêËóèÔºåËß¶Êë∏ËÆæÂ§áÊòæÁ§∫ */
        #mobile-controls { display: none; position: absolute; bottom: 20px; width: 100%; padding: 0 20px; box-sizing: border-box; justify-content: space-between; pointer-events: none; }
        .touch-zone { pointer-events: auto; display: flex; gap: 15px; }
        .t-btn { width: 70px; height: 70px; border-radius: 50%; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2); color: white; display: flex; justify-content: center; align-items: center; font-size: 24px; backdrop-filter: blur(5px); touch-action: none; }
        .t-btn:active { background: rgba(255,255,255,0.3); transform: scale(0.95); }
        
        @media (hover: none) and (pointer: coarse) {
            #mobile-controls { display: flex; }
            .key-guide { display: none; }
        }
    </style>
</head>
<body>

<div id="ui-layer">
    <div class="hud-top">
        <div id="p1-bar" class="bar-container">
            <div class="name"><span>PLAYER 1</span> <span style="font-size:14px; opacity:0.7">KEYS: WASD + J/K/L/I</span></div>
            <div class="hp-track"><div id="p1-hp" class="hp-fill"></div></div>
            <div class="mp-track" id="p1-mp-track"><div id="p1-mp" class="mp-fill"></div></div>
        </div>
        <div id="p2-bar" class="bar-container">
            <div class="name"><span>CPU (AI)</span></div>
            <div class="hp-track"><div id="p2-hp" class="hp-fill"></div></div>
            <div class="mp-track"><div id="p2-mp" class="mp-fill"></div></div>
        </div>
    </div>
    <div class="center-msg">
        <div id="combo-display" class="combo-counter"></div>
        <div id="ko-display" class="ko-text">K.O.</div>
    </div>
    <div id="mobile-controls">
        <div class="touch-zone" style="align-items: flex-end;">
            <div class="t-btn" id="btn-l">‚¨ÖÔ∏è</div>
            <div class="t-btn" id="btn-r">‚û°Ô∏è</div>
        </div>
        <div class="touch-zone" style="align-items: flex-end;">
            <div class="t-btn" id="btn-dash" style="width:50px; height:50px; margin-bottom:10px;">üí®</div>
            <div class="t-btn" id="btn-atk" style="width:90px; height:90px; border-color:#ff5555; background:rgba(255,80,80,0.1)">üëä</div>
            <div class="t-btn" id="btn-jump">üöÄ</div>
            <div class="t-btn" id="btn-ult" style="position:absolute; top:-80px; right: 20px; border-color:#00eaff; font-size:16px;">‚ö°ULT</div>
        </div>
    </div>
</div>

<div id="overlay">
    <h1>NEON BLADE</h1>
    <h2>// OVERDRIVE EDITION</h2>
    
    <div class="key-guide">
        <div>
            <h3>MOVEMENT</h3>
            <p><span class="key">A</span> <span class="key">D</span> Move</p>
            <p><span class="key">W</span> Jump</p>
            <p><span class="key">S</span> Block (Hold)</p>
        </div>
        <div>
            <h3>COMBAT</h3>
            <p><span class="key">J</span> Attack</p>
            <p><span class="key">K</span> Heavy / Air</p>
            <p><span class="key">L</span> Dash</p>
            <p><span class="key">I</span> ULTIMATE</p>
        </div>
    </div>

    <button id="start-btn">INITIALIZE SYSTEM</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
/**
 * AUDIO ENGINE (Synthesizer)
 * No external assets needed. Pure math.
 */
const AudioEngine = {
    ctx: null,
    init() {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
    },
    playTone(freq, type, duration, vol=0.1) {
        if(!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(freq/2, this.ctx.currentTime + duration);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    playNoise(duration, vol=0.2) {
        if(!this.ctx) return;
        const bufferSize = this.ctx.sampleRate * duration;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        noise.connect(gain);
        gain.connect(this.ctx.destination);
        noise.start();
    },
    sfx: {
        hit: () => { AudioEngine.playNoise(0.1, 0.3); AudioEngine.playTone(150, 'sawtooth', 0.1, 0.2); },
        swing: () => AudioEngine.playNoise(0.05, 0.1),
        jump: () => AudioEngine.playTone(300, 'sine', 0.2, 0.1),
        dash: () => AudioEngine.playNoise(0.2, 0.15),
        block: () => AudioEngine.playTone(100, 'square', 0.1, 0.2),
        ult: () => { AudioEngine.playTone(800, 'sawtooth', 1.0, 0.3); AudioEngine.playNoise(1.0, 0.5); }
    }
};

/**
 * GAME ENGINE
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let width, height;

// State
let lastTime = 0;
let timeScale = 1.0;
let shake = 0;
let gameOver = false;
let particles = [];

// Input
const keys = {
    a: false, d: false, w: false, s: false, // Move
    j: false, k: false, l: false, i: false  // Action
};

// World Config
const GRAVITY = 0.8;
const GROUND_Y = 120; // Distance from bottom

class Particle {
    constructor(x, y, color, speed, size, life) {
        this.x = x; this.y = y;
        this.vx = (Math.random() - 0.5) * speed;
        this.vy = (Math.random() - 0.5) * speed;
        this.color = color;
        this.size = size;
        this.life = life;
        this.maxLife = life;
    }
    update() {
        this.x += this.vx * timeScale;
        this.y += this.vy * timeScale;
        this.life -= 0.05 * timeScale;
    }
    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life / this.maxLife);
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.size, this.size);
        ctx.globalAlpha = 1;
    }
}

class Fighter {
    constructor(x, color, name, isAi) {
        this.x = x; this.y = 0;
        this.vx = 0; this.vy = 0;
        this.w = 50; this.h = 100;
        this.color = color;
        this.name = name;
        this.isAi = isAi;
        
        this.maxHp = 500; this.hp = this.maxHp;
        this.maxMp = 100; this.mp = 0;
        
        this.dir = 1;
        this.state = 'idle'; // idle, run, jump, attack, hit, block, dead, dash
        this.animTimer = 0;
        
        this.combo = 0;
        this.lastAtkTime = 0;
        this.hitStun = 0;
    }

    reset(x) {
        this.x = x; this.y = 0; this.vx = 0; this.vy = 0;
        this.hp = this.maxHp; this.mp = 0;
        this.state = 'idle'; this.combo = 0; this.dead = false;
    }

    update(target) {
        if (this.dead) return;

        // Physics
        this.vy += GRAVITY * timeScale;
        this.x += this.vx * timeScale;
        this.y += this.vy * timeScale;

        // Ground collision
        const ground = height - GROUND_Y;
        if (this.y + this.h > ground) {
            this.y = ground - this.h;
            this.vy = 0;
            if (this.state === 'jump' || this.state === 'hit') {
                this.state = 'idle';
                this.vx = 0;
            }
        }
        
        // Wall collision
        if (this.x < 0) this.x = 0;
        if (this.x > width - this.w) this.x = width - this.w;

        // Friction
        if (this.state !== 'dash' && this.state !== 'jump') {
            this.vx *= 0.8;
        }

        // Stun logic
        if (this.hitStun > 0) {
            this.hitStun -= 1 * timeScale;
            if (this.hitStun <= 0 && this.state === 'hit') this.state = 'idle';
            return;
        }

        // Facing
        if (this.state !== 'attack' && this.state !== 'ult') {
            if (target.x > this.x + this.w) this.dir = 1;
            else if (target.x < this.x) this.dir = -1;
        }

        if (this.isAi) this.aiLogic(target);
        else this.playerLogic();

        this.animTimer += timeScale;
    }

    playerLogic() {
        if (['hit', 'attack', 'ult', 'dash'].includes(this.state)) return;

        // Block
        if (keys.s && Math.abs(this.vx) < 1) {
            this.state = 'block';
            return;
        } else if (this.state === 'block') {
            this.state = 'idle';
        }

        // Move
        if (keys.a) { this.vx = -6; this.state = 'run'; this.dir = -1; }
        else if (keys.d) { this.vx = 6; this.state = 'run'; this.dir = 1; }
        else if (this.state === 'run') { this.state = 'idle'; }

        // Jump
        if (keys.w && this.vy === 0) {
            this.vy = -22;
            this.state = 'jump';
            AudioEngine.sfx.jump();
            keys.w = false; // Prevent hold
        }

        // Dash
        if (keys.l && this.mp >= 20) {
            this.performDash();
            keys.l = false;
        }

        // Attack
        if (keys.j) { this.attack('light'); keys.j = false; }
        
        // Ult
        if (keys.i && this.mp >= 100) { this.ultimate(); keys.i = false; }
    }

    aiLogic(target) {
        if (['hit', 'attack', 'ult', 'dash'].includes(this.state)) return;

        const dist = Math.abs((this.x + this.w/2) - (target.x + target.w/2));
        const dy = Math.abs(this.y - target.y);

        // Defensive Block: If player is attacking and close, block randomly
        if (target.state === 'attack' && dist < 120 && Math.random() < 0.6) {
            this.state = 'block';
            this.vx = 0;
            return;
        } else if (this.state === 'block') {
            this.state = 'idle';
        }

        // Movement
        if (dist > 80) {
            this.vx = 4 * (target.x > this.x ? 1 : -1);
            this.state = 'run';
        } else {
            if (Math.random() < 0.05) this.attack('light');
            this.vx = 0;
            this.state = 'idle';
        }

        // Random Jump or Dash
        if (Math.random() < 0.01 && this.vy === 0) {
            this.vy = -22; this.state = 'jump';
        }
        if (Math.random() < 0.01 && this.mp > 20) this.performDash();
        
        // AI Ult
        if (this.mp >= 100 && dist < 200 && Math.random() < 0.05) this.ultimate();
    }

    performDash() {
        this.mp -= 20;
        this.state = 'dash';
        this.vx = 25 * this.dir;
        this.vy = 0;
        AudioEngine.sfx.dash();
        // Ghost effect
        for(let i=0; i<5; i++) {
            particles.push(new Particle(this.x - i*10*this.dir, this.y, this.color, 0, 10, 20));
        }
        setTimeout(() => { if(this.state === 'dash') this.state = 'idle'; }, 200);
    }

    attack(type) {
        if (Date.now() - this.lastAtkTime < 200) return; // Cooldown
        
        this.state = 'attack';
        this.lastAtkTime = Date.now();
        this.vx = 5 * this.dir; // Small lung
        AudioEngine.sfx.swing();
        
        // Combo Logic
        this.combo = (this.combo % 3) + 1;
        
        // Hitbox
        const reach = 80;
        const damage = 20 + (this.combo * 5);
        
        // Visuals
        const hitboxX = this.dir === 1 ? this.x + this.w : this.x - reach;
        createImpact(hitboxX + (this.dir===1?0:reach), this.y + 40, '#fff', 2); // Swipe effect

        // Check Hit
        const target = this === p1 ? p2 : p1;
        if (Math.abs((this.x + this.w/2) - (target.x + target.w/2)) < (this.w/2 + reach) && 
            Math.abs(this.y - target.y) < 100) {
            
            // Block Check
            if (target.state === 'block' && target.dir !== this.dir) {
                // Blocked!
                target.vx = 10 * this.dir; // Pushback
                this.vx = -5 * this.dir; // Recoil
                AudioEngine.sfx.block();
                createFloatingText(target.x, target.y, "BLOCK", '#aaa');
                shake = 2;
                this.mp = Math.min(this.maxMp, this.mp + 5);
            } else {
                // Hit!
                target.takeDamage(damage, this.dir);
                this.mp = Math.min(this.maxMp, this.mp + 15);
                shake = 5 * this.combo;
                // Pause frame
                timeScale = 0.1;
                setTimeout(() => timeScale = 1.0, 50);
                
                // Combo Counter (Visual only)
                if (this === p1) updateCombo(this.combo);
            }
        }
        
        setTimeout(() => { if (this.state === 'attack') this.state = 'idle'; }, 300);
    }

    ultimate() {
        this.mp = 0;
        this.state = 'ult';
        AudioEngine.sfx.ult();
        
        // Cinematic Freeze
        timeScale = 0;
        shake = 20;
        
        // Darken Screen Effect (Handled in draw loop)
        setTimeout(() => {
            timeScale = 1.0;
            // Massive Hit
            const target = this === p1 ? p2 : p1;
            // Unblockable damage
            target.takeDamage(120, this.dir);
            shake = 30;
            // Flash white
            ctx.fillStyle = 'white';
            ctx.fillRect(0,0,width,height);
            this.state = 'idle';
        }, 1000);
    }

    takeDamage(amt, hitDir) {
        if (this.state === 'dead' || this.state === 'dash') return;
        
        this.hp -= amt;
        this.state = 'hit';
        this.hitStun = 20;
        this.vx = 15 * hitDir;
        this.vy = -5;
        
        createImpact(this.x + this.w/2, this.y + 30, '#ff0000', 15);
        createFloatingText(this.x, this.y, amt, '#fff');
        AudioEngine.sfx.hit();

        if (this.hp <= 0) {
            this.hp = 0;
            this.die();
        }
    }

    die() {
        this.state = 'dead';
        this.dead = true;
        this.vx = -10 * this.dir;
        this.vy = -10;
        
        // Slow Motion Finish
        timeScale = 0.2;
        setTimeout(() => { timeScale = 1.0; endGame(this === p1 ? 'LOSE' : 'WIN'); }, 1000);
        
        document.getElementById('ko-display').style.display = 'block';
    }

    draw(ctx) {
        const cx = this.x + this.w/2;
        const cy = this.y;
        
        ctx.save();
        ctx.translate(cx, cy + this.h);
        ctx.scale(this.dir, 1);
        
        // Determine Colors
        let mainC = this.color;
        let glowC = this.color;
        
        if (this.state === 'hit') mainC = '#fff';
        if (this.state === 'ult') { mainC = '#fff'; glowC = '#00ffff'; ctx.shadowBlur = 30; }
        else ctx.shadowBlur = 10;
        
        ctx.shadowColor = glowC;
        ctx.fillStyle = mainC;
        ctx.strokeStyle = mainC;
        ctx.lineWidth = 4;

        // Stickman Drawing Logic
        // Legs
        ctx.beginPath();
        if (this.state === 'run') {
            const runO = Math.sin(this.animTimer * 0.8) * 20;
            ctx.moveTo(-10, -40); ctx.lineTo(-20 + runO, 0); // Back Leg
            ctx.moveTo(10, -40); ctx.lineTo(20 - runO, 0);  // Front Leg
        } else if (this.state === 'jump') {
            ctx.moveTo(-10, -40); ctx.lineTo(-20, -10);
            ctx.moveTo(10, -40); ctx.lineTo(20, -20);
        } else {
            ctx.moveTo(-10, -40); ctx.lineTo(-20, 0);
            ctx.moveTo(10, -40); ctx.lineTo(20, 0);
        }
        ctx.stroke();

        // Body
        ctx.fillRect(-15, -80, 30, 40);

        // Head
        ctx.beginPath(); ctx.arc(0, -90, 12, 0, Math.PI*2); ctx.fill();
        
        // Block Shield
        if (this.state === 'block') {
            ctx.strokeStyle = '#00eaff';
            ctx.beginPath(); ctx.arc(25, -60, 40, -Math.PI/3, Math.PI/3); ctx.stroke();
        }

        // Arms / Attack Animation
        ctx.strokeStyle = mainC;
        ctx.beginPath();
        if (this.state === 'attack') {
            // Punch
            ctx.moveTo(10, -70); ctx.lineTo(60, -70); 
            ctx.lineWidth = 10; ctx.stroke(); ctx.lineWidth = 4;
            // Impact Effect
            ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(65, -70, 15, 0, Math.PI*2); ctx.fill();
        } else if (this.state === 'block') {
            ctx.moveTo(-10, -70); ctx.lineTo(15, -60);
            ctx.moveTo(10, -70); ctx.lineTo(20, -50);
            ctx.stroke();
        } else {
            // Idle/Run Arms
            const armO = this.state === 'run' ? Math.sin(this.animTimer*0.8)*20 : 0;
            ctx.moveTo(-10, -70); ctx.lineTo(0 + armO, -30);
            ctx.moveTo(10, -70); ctx.lineTo(20 - armO, -30);
            ctx.stroke();
        }

        ctx.restore();
    }
}

// Global Objects
let p1, p2;

// --- Game Logic Functions ---

function createImpact(x, y, color, count) {
    for(let i=0; i<count; i++) {
        particles.push(new Particle(x, y, color, 15, Math.random()*5+2, 20));
    }
}

function createFloatingText(x, y, text, color) {
    const el = document.createElement('div');
    el.style.position = 'absolute';
    el.style.left = x + 'px';
    el.style.top = y + 'px';
    el.style.color = color;
    el.style.fontWeight = 'bold';
    el.style.fontSize = '30px';
    el.style.textShadow = '0 0 5px #000';
    el.style.pointerEvents = 'none';
    el.innerText = text;
    el.animate([
        { transform: 'translate(0, 0) scale(1)', opacity: 1 },
        { transform: 'translate(0, -100px) scale(1.5)', opacity: 0 }
    ], { duration: 800, fill: 'forwards' });
    document.body.appendChild(el);
    setTimeout(() => el.remove(), 800);
}

let comboCount = 0;
let comboTimer = null;
function updateCombo(val) {
    comboCount++;
    const el = document.getElementById('combo-display');
    el.innerText = comboCount + " HITS";
    el.style.opacity = 1;
    el.style.transform = "scale(1.5)";
    setTimeout(() => el.style.transform = "scale(1)", 100);
    
    clearTimeout(comboTimer);
    comboTimer = setTimeout(() => {
        comboCount = 0;
        el.style.opacity = 0;
    }, 2000);
}

function initGame() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    
    p1 = new Fighter(100, '#00ff88', 'HERO', false);
    p2 = new Fighter(width - 200, '#ff0055', 'VILLAIN', true);
    
    gameOver = false;
    timeScale = 1.0;
    particles = [];
    document.getElementById('ko-display').style.display = 'none';
    
    // UI Updates
    updateHUD();
}

function updateHUD() {
    if(!p1) return;
    document.getElementById('p1-hp').style.width = (p1.hp / p1.maxHp * 100) + '%';
    document.getElementById('p1-mp').style.width = p1.mp + '%';
    document.getElementById('p2-hp').style.width = (p2.hp / p2.maxHp * 100) + '%';
    document.getElementById('p2-mp').style.width = p2.mp + '%';
}

function endGame(result) {
    if(gameOver) return;
    gameOver = true;
    setTimeout(() => {
        document.querySelector('h1').innerText = result === 'WIN' ? 'MISSION ACCOMPLISHED' : 'SYSTEM FAILURE';
        document.querySelector('h2').innerText = result === 'WIN' ? 'Target Eliminated' : 'Critical Damage Sustained';
        document.getElementById('overlay').style.display = 'flex';
        document.getElementById('start-btn').innerText = "REBOOT SYSTEM";
    }, 2000);
}

// --- Main Loop ---

function drawBackground() {
    // Parallax logic
    const camX = (p1.x + p2.x) / 2 - width/2;
    
    // Grid Floor
    ctx.fillStyle = '#111';
    ctx.fillRect(0, height - GROUND_Y, width, GROUND_Y);
    ctx.strokeStyle = '#00eaff';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(0, height - GROUND_Y); ctx.lineTo(width, height - GROUND_Y); ctx.stroke();
    
    // Perspective Lines
    ctx.globalAlpha = 0.2;
    for(let i=-width; i<width*2; i+=100) {
        let x = i - camX * 0.5;
        ctx.beginPath(); ctx.moveTo(x + (i%200)*2, height); ctx.lineTo(x, height - GROUND_Y); ctx.stroke();
    }
    
    // Cyber Buildings (Far background)
    ctx.globalAlpha = 0.5;
    ctx.fillStyle = '#0a0a0a';
    for(let i=0; i<10; i++) {
        let h = 200 + Math.sin(i)*100;
        let x = (i * 150) - (camX * 0.1);
        // Wrap around
        if (x < -100) x += width + 200; 
        if (x > width + 100) x -= (width + 200);
        ctx.fillRect(x, height - GROUND_Y - h, 80, h);
        // Neon windows
        ctx.fillStyle = i%2==0 ? '#ff0055' : '#00ff88';
        ctx.fillRect(x + 10, height - GROUND_Y - h + 20, 5, 5);
        ctx.fillStyle = '#0a0a0a';
    }
    ctx.globalAlpha = 1;
}

function loop() {
    requestAnimationFrame(loop);
    
    // Handle Shake
    let dx = 0, dy = 0;
    if(shake > 0) {
        dx = (Math.random()-0.5) * shake;
        dy = (Math.random()-0.5) * shake;
        shake *= 0.9;
        if(shake < 0.5) shake = 0;
    }
    
    ctx.save();
    ctx.translate(dx, dy);
    
    // Clear
    ctx.fillStyle = '#050505';
    ctx.fillRect(0, 0, width, height);
    
    if(!p1) { ctx.restore(); return; } // Not started

    drawBackground();

    if (!gameOver) {
        p1.update(p2);
        p2.update(p1);
    }
    updateHUD();

    p1.draw(ctx);
    p2.draw(ctx);
    
    // Particles
    for(let i=particles.length-1; i>=0; i--) {
        particles[i].update();
        particles[i].draw(ctx);
        if(particles[i].life <= 0) particles.splice(i, 1);
    }

    // Ult Overlay
    if(p1.state === 'ult' || p2.state === 'ult') {
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.globalCompositeOperation = 'destination-over'; // Draw behind players but over BG
        ctx.fillRect(0,0,width,height);
        ctx.globalCompositeOperation = 'source-over';
    }

    ctx.restore();
}

// --- Controls Setup ---

function bindKey(key, action) {
    if(keys.hasOwnProperty(key)) keys[key] = action;
}

window.addEventListener('keydown', e => {
    const k = e.key.toLowerCase();
    if(keys.hasOwnProperty(k)) keys[k] = true;
});
window.addEventListener('keyup', e => {
    const k = e.key.toLowerCase();
    if(keys.hasOwnProperty(k)) keys[k] = false;
});

// Touch Controls
const touchMap = {
    'btn-l': 'a', 'btn-r': 'd', 'btn-jump': 'w',
    'btn-atk': 'j', 'btn-dash': 'l', 'btn-ult': 'i'
};

Object.keys(touchMap).forEach(id => {
    const el = document.getElementById(id);
    const key = touchMap[id];
    el.addEventListener('touchstart', (e) => { e.preventDefault(); keys[key] = true; });
    el.addEventListener('touchend', (e) => { e.preventDefault(); keys[key] = false; });
    el.addEventListener('mousedown', () => keys[key] = true);
    el.addEventListener('mouseup', () => keys[key] = false);
});

// Start
document.getElementById('start-btn').onclick = () => {
    AudioEngine.init();
    if(AudioEngine.ctx.state === 'suspended') AudioEngine.ctx.resume();
    document.getElementById('overlay').style.display = 'none';
    initGame();
};

window.addEventListener('resize', () => {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    if(p1) { p1.y = height - GROUND_Y - p1.h; }
});

// Start Loop
loop();

</script>
</body>
</html>