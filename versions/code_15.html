<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>PHANTOM EDGE: DIMENSION CUT</title>
    <style>
        /* 基础重置 */
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Courier New', sans-serif; touch-action: none; user-select: none; -webkit-user-select: none; }
        
        /* 游戏容器：核心层 */
        #game-container {
            position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
            background: #000; overflow: hidden;
            transform-origin: center center;
            transition: width 0.3s, height 0.3s, transform 0.3s;
        }

        canvas { display: block; width: 100%; height: 100%; }

        /* UI HUD 层 */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; padding: 20px; box-sizing: border-box; display: flex; flex-direction: column; justify-content: space-between; }
        
        /* 顶部血条 */
        .hud-top { display: flex; justify-content: space-between; width: 100%; }
        .bar-box { width: 42%; position: relative; }
        .name-tag { color: #fff; font-weight: 900; font-size: 16px; margin-bottom: 4px; text-shadow: 0 0 5px currentColor; display:flex; justify-content: space-between; align-items: flex-end;}
        .hp-frame { height: 16px; background: rgba(30,30,30,0.8); border: 2px solid #555; transform: skewX(-20deg); overflow: hidden; position: relative; }
        .hp-fill { height: 100%; width: 100%; transition: width 0.1s linear; }
        .hp-bg-damage { position:absolute; top:0; left:0; height:100%; width:100%; background: #fff; transition: width 0.5s 0.2s; z-index: -1; }
        
        .mp-frame { height: 6px; width: 80%; background: #111; border: 1px solid #333; margin-top: 4px; transform: skewX(-20deg); }
        .mp-fill { height: 100%; width: 0%; background: #00eaff; box-shadow: 0 0 10px #00eaff; transition: width 0.1s; }

        /* 玩家颜色 */
        #p1-bar .name-tag { color: #00eaff; }
        #p1-hp { background: linear-gradient(90deg, #00eaff, #0088aa); float: right; }
        #p1-mp-frame { float: right; }

        #p2-bar .name-tag { color: #ff0055; flex-direction: row-reverse; }
        #p2-hp { background: linear-gradient(90deg, #ff0055, #aa0033); float: left; }
        
        /* 连击字样 */
        #center-msg { position: absolute; top: 20%; left: 50%; transform: translateX(-50%); text-align: center; pointer-events: none; }
        .combo-text { font-size: 50px; font-weight: 900; font-style: italic; color: #ffeb3b; text-shadow: 4px 4px 0 #000; opacity: 0; transition: transform 0.05s; }
        .clash-text { font-size: 80px; color: #fff; text-shadow: 0 0 20px #fff; opacity: 0; letter-spacing: 5px; }

        /* 虚拟控制器 (仅触摸屏显示) */
        #controls-layer { position: absolute; inset: 0; pointer-events: none; z-index: 10; display: none; }
        
        /* 左侧摇杆槽 */
        .joystick-track { 
            position: absolute; bottom: 40px; left: 40px; width: 200px; height: 60px; 
            background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2); 
            border-radius: 30px; pointer-events: auto; backdrop-filter: blur(4px);
            display: flex; align-items: center; justify-content: center;
        }
        .joystick-thumb {
            width: 80px; height: 50px; background: rgba(0, 234, 255, 0.3); border: 2px solid #00eaff; 
            border-radius: 25px; box-shadow: 0 0 15px #00eaff; transform: translateX(0);
        }
        .joy-label { position: absolute; top: -30px; left: 0; color: #aaa; font-size: 12px; width: 100%; text-align: center; }

        /* 右侧手势区 */
        .gesture-zone {
            position: absolute; bottom: 0; right: 0; width: 50%; height: 100%;
            pointer-events: auto;
            /* background: rgba(255, 0, 0, 0.1); Debug use */ 
        }
        .gesture-hint {
            position: absolute; bottom: 50px; right: 50px; text-align: right; color: rgba(255,255,255,0.3);
            font-size: 14px; line-height: 1.5; pointer-events: none;
        }

        /* 启动遮罩 */
        #start-overlay {
            position: absolute; inset: 0; background: #000; z-index: 999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        h1 { color: #fff; font-size: 40px; margin: 0; font-style: italic; text-shadow: 0 0 20px #00eaff; letter-spacing: -2px; }
        p { color: #888; margin-top: 5px; margin-bottom: 30px; font-size: 14px; }
        #btn-start {
            background: transparent; border: 2px solid #00eaff; color: #00eaff;
            padding: 15px 40px; font-size: 20px; font-weight: bold; cursor: pointer;
            box-shadow: 0 0 15px rgba(0,234,255,0.2); transition: 0.2s;
        }
        #btn-start:active { background: #00eaff; color: #000; }
        
        /* 移动端横屏强制修正类 */
        .force-landscape {
            width: 100vh !important; height: 100vw !important;
            transform: rotate(90deg);
            position: absolute; top: 50%; left: 50%;
            margin-left: -50vh; margin-top: -50vw; /* Center correction */
        }
        
        /* 结算界面样式 */
        #game-over-overlay {
            position: absolute; inset: 0; background: rgba(0,0,0,0.9); z-index: 1000;
            display: none; flex-direction: column; justify-content: center; align-items: center;
        }
        .result-title { font-size: 80px; font-weight: 900; font-style: italic; margin-bottom: 20px; }
        .win-text { color: #00eaff; text-shadow: 0 0 30px #00eaff; }
        .lose-text { color: #ff0055; text-shadow: 0 0 30px #ff0055; }
        
        #btn-restart {
            background: #fff; color: #000; border: none;
            padding: 15px 50px; font-size: 24px; font-weight: 900; transform: skewX(-10deg);
            cursor: pointer; box-shadow: 5px 5px 0 #555; transition: transform 0.1s;
        }
        #btn-restart:active { transform: skewX(-10deg) scale(0.95); box-shadow: 2px 2px 0 #555; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="canvas"></canvas>
    
    <div id="ui-layer">
        <div class="hud-top">
            <div id="p1-bar" class="bar-box">
                <div class="name-tag"><span>P1</span><span>NEON</span></div>
                <div class="hp-frame">
                    <div class="hp-bg-damage" id="p1-hp-dmg"></div>
                    <div id="p1-hp" class="hp-fill"></div>
                </div>
                <div class="mp-frame" id="p1-mp-frame"><div id="p1-mp" class="mp-fill"></div></div>
            </div>
            <div id="p2-bar" class="bar-box">
                <div class="name-tag"><span>CPU</span><span>SHADOW</span></div>
                <div class="hp-frame">
                    <div class="hp-bg-damage" id="p2-hp-dmg"></div>
                    <div id="p2-hp" class="hp-fill"></div>
                </div>
                <div class="mp-frame"><div id="p2-mp" class="mp-fill"></div></div>
            </div>
        </div>
        
        <div id="center-msg">
            <div id="combo-display" class="combo-text"></div>
            <div id="clash-display" class="clash-text">CLASH!!</div>
        </div>
    </div>

    <!-- 触摸控制器 -->
    <div id="controls-layer">
        <div class="joystick-track" id="stick-track">
            <div class="joy-label">&lt; MOVE &gt;</div>
            <div class="joystick-thumb" id="stick-thumb"></div>
        </div>
        <div class="gesture-zone" id="gesture-pad">
            <div class="gesture-hint">
                TAP : ATTACK<br>
                SWIPE UP : JUMP<br>
                SWIPE DOWN : ULT
            </div>
        </div>
    </div>
</div>

<div id="start-overlay">
    <h1>PHANTOM EDGE</h1>
    <p>横屏动作体验 / LANDSCAPE ACTION</p>
    <button id="btn-start">⚡ START FULLSCREEN</button>
</div>

<div id="game-over-overlay">
    <div id="result-title" class="result-title">VICTORY</div>
    <button id="btn-restart">RETRY MISSION</button>
</div>

<script>
/**
 * AUDIO ENGINE (Web Audio API)
 * 生成所有音效，无外部素材。
 */
const AudioSys = {
    ctx: null,
    init() {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
    },
    playTone(freq, type, duration, vol=0.1, slide=0) {
        if(!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        if(slide) osc.frequency.exponentialRampToValueAtTime(slide, this.ctx.currentTime + duration);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain); gain.connect(this.ctx.destination);
        osc.start(); osc.stop(this.ctx.currentTime + duration);
    },
    noise(duration, vol=0.2) {
        if(!this.ctx) return;
        const bSize = this.ctx.sampleRate * duration;
        const buf = this.ctx.createBuffer(1, bSize, this.ctx.sampleRate);
        const data = buf.getChannelData(0);
        for(let i=0; i<bSize; i++) data[i] = Math.random() * 2 - 1;
        const src = this.ctx.createBufferSource();
        src.buffer = buf;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        src.connect(gain); gain.connect(this.ctx.destination);
        src.start();
    },
    sfx: {
        swing: () => AudioSys.noise(0.1, 0.1),
        hit: () => { AudioSys.noise(0.2, 0.3); AudioSys.playTone(100, 'sawtooth', 0.2, 0.2, 50); },
        clash: () => { AudioSys.playTone(800, 'square', 0.1, 0.3); AudioSys.playTone(1200, 'sine', 0.3, 0.3, 100); }, // 拼刀清脆声
        jump: () => AudioSys.playTone(200, 'sine', 0.2, 0.1, 400),
        ultCast: () => { AudioSys.playTone(50, 'square', 1.0, 0.2); AudioSys.playTone(1000, 'sawtooth', 1.0, 0.1, 100); }, // 蓄力
        slash: () => { AudioSys.noise(0.05, 0.2); AudioSys.playTone(2000, 'triangle', 0.05, 0.1, 1000); }, // 锐利切削
        ultBoom: () => { AudioSys.noise(1.0, 0.8); AudioSys.playTone(50, 'sawtooth', 1.5, 0.5, 10); } // 爆炸
    }
};
// 在 AudioSys 代码块下方添加：
const platforms = [
    { x: 200, y: 350, w: 200, h: 20 }, // 左侧二楼
    { x: 600, y: 200, w: 200, h: 20 }, // 右侧三楼
    { x: 450, y: 300, w: 100, h: 20 }  // 中间跳板
];

/**
 * GAME ENGINE & LOGIC
 */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const container = document.getElementById('game-container');

let W, H;
let timeScale = 1.0;
let shake = 0;
let flash = 0; // 屏幕白闪
let darkOverlay = 0; // 屏幕压暗

// Camera
let cam = { x: 0, y: 0, zoom: 1, targetZoom: 1 };

// Particles
let particles = [];
let slashLines = []; // 大招专用乱刃

class Particle {
    constructor(x, y, color, speed, size, life, type='box') {
        this.x = x; this.y = y; this.color = color;
        this.vx = (Math.random()-0.5)*speed; this.vy = (Math.random()-0.5)*speed;
        this.life = life; this.maxLife = life; this.size = size; this.type = type;
        if(type==='shard') { this.rotation = Math.random()*6; this.vRot = (Math.random()-0.5)*0.5; }
    }
    update() {
        this.x += this.vx * timeScale; this.y += this.vy * timeScale;
        this.life -= 0.02 * timeScale;
        if(this.type === 'shard') this.rotation += this.vRot * timeScale;
    }
    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life/this.maxLife);
        ctx.fillStyle = this.color;
        if(this.type === 'box') {
            ctx.fillRect(this.x, this.y, this.size, this.size);
        } else if (this.type === 'shard') {
            ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation);
            ctx.beginPath(); ctx.moveTo(-this.size, this.size); ctx.lineTo(0, -this.size); ctx.lineTo(this.size, this.size); ctx.fill();
            ctx.restore();
        }
        ctx.globalAlpha = 1;
    }
}

let damageTexts = []; // 伤害飘字数组
let uiCombo = 0;      // UI连击计数
let uiComboTimer = null;

class DamageText {
    constructor(x, y, dmg, isCrit) {
        this.x = x + (Math.random()-0.5)*20;
        this.y = y - 20;
        this.text = Math.floor(dmg);
        this.vy = -3 - Math.random()*2; // 向上崩飞
        this.vx = (Math.random()-0.5)*2;
        this.life = 1.0;
        this.color = isCrit ? '#ffeb3b' : '#fff'; // 暴击(连击高)金色，普通白色
        this.scale = isCrit ? 1.5 : 1.0;
    }
    update() {
        this.x += this.vx * timeScale;
        this.y += this.vy * timeScale;
        this.vy += 0.15 * timeScale; // 重力下坠
        this.life -= 0.02 * timeScale;
    }
    draw(ctx) {
        ctx.save();
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.shadowColor = '#000'; ctx.shadowBlur = 0; // 去掉光晕保持清晰
        ctx.font = `900 ${20 * this.scale}px 'Courier New'`;
        ctx.textAlign = 'center';
        ctx.fillText(this.text, this.x, this.y);
        ctx.strokeText(this.text, this.x, this.y); // 描边增加可读性
        ctx.restore();
    }
}

class Fighter {
    constructor(x, color, isAi) {
        this.x = x; this.y = 0; this.vx = 0; this.vy = 0;
        this.w = 40; this.h = 90;
        this.color = color; this.isAi = isAi;
        this.dir = 1;
        this.hp = 500; this.maxHp = 500; this.mp = 0;
        this.state = 'idle'; 
        this.animTimer = 0;
        
        // Combat stats
        this.combo = 0;
        this.lastAtk = 0;
        this.inAir = false;
        
        // Ult specific
        this.ultTimer = 0;
        this.target = null;
    }

    update(dt, enemy) {
        // AI Logic
        if(this.isAi && this.state !== 'dead' && this.state !== 'ult_frozen') {
            this.aiUpdate(enemy);
        }

        // Physics
        this.vy += 0.8 * timeScale; // Gravity
        this.x += this.vx * timeScale;
        this.y += this.vy * timeScale;

        // --- 物理与碰撞逻辑开始 ---
        
        let onGround = false;
        const groundY = H - 100;

        // 1. 平台碰撞检测 (单向平台：只能从上往下踩)
        // 只有当角色向下落(vy >= 0)时才检测
        if (this.vy >= 0) {
            for (let p of platforms) {
                // 判定条件：
                // 1. 角色在平台水平范围内
                // 2. 角色脚底 (y+h) 刚刚穿过平台表面 (p.y)
                // 3. 容错：上一帧脚底在平台上方 (this.y + this.h - this.vy <= p.y)
                if (this.x + this.w > p.x && this.x < p.x + p.w &&
                    this.y + this.h >= p.y && this.y + this.h <= p.y + this.vy + 20) { // +20是防穿透容错
                    
                    this.y = p.y - this.h;
                    this.vy = 0;
                    this.inAir = false;
                    onGround = true;
                    if(this.state === 'jump' || this.state === 'hit') this.state = 'idle';
                    break; // 只要踩到一个平台就停止检测
                }
            }
        }

        // 2. 地面碰撞检测 (如果没踩在平台上)
        if (!onGround) {
            if (this.y + this.h >= groundY) {
                this.y = groundY - this.h;
                this.vy = 0;
                this.inAir = false;
                if(this.state === 'jump' || this.state === 'hit') this.state = 'idle';
            } else {
                this.inAir = true;
            }
        }
        // --- 物理与碰撞逻辑结束 ---

        // Friction
        if(this.state !== 'dash' && this.state !== 'jump' && !this.inAir) this.vx *= 0.8;

        // Wall
        if(this.x < 0) this.x = 0;
        if(this.x > W - this.w) this.x = W - this.w;

        // Facing
        if(this.state !== 'ult_cast' && this.state !== 'ult_slash' && this.state !== 'ult_end') {
            if(enemy.x > this.x) this.dir = 1; else this.dir = -1;
        }

        // Update Animation
        this.animTimer += timeScale;

        // Ult Sequence State Machine
        if(this.state === 'ult_cast') {
            this.ultTimer++;
            if(this.ultTimer > 40) { // Cast finish -> Teleport & Slash
                this.state = 'ult_slash';
                this.ultTimer = 0;
                // Teleport to enemy
                this.x = enemy.x - (100 * this.dir); // Behind enemy? No, logic: 
                // Wait, if vergil style, he disappears.
                // Generate slash lines
                for(let i=0; i<15; i++) {
                    slashLines.push({
                        x: enemy.x + enemy.w/2 + (Math.random()-0.5)*200,
                        y: enemy.y + enemy.h/2 + (Math.random()-0.5)*200,
                        len: 100 + Math.random()*200,
                        angle: Math.random() * Math.PI * 2,
                        delay: Math.random() * 30, // Frames delay
                        life: 10
                    });
                }
            }
        } else if (this.state === 'ult_slash') {
            this.ultTimer++;
            // Rapid Slashes Sounds
            if(this.ultTimer % 4 === 0) {
                AudioSys.sfx.slash();
                shake = 5;
                enemy.state = 'ult_frozen'; // Ensure enemy stays frozen
            }
            if(this.ultTimer > 60) { // Slashes done -> Sheath
                this.state = 'ult_end';
                this.ultTimer = 0;
                
                // === v14 修复：智能瞬移逻辑 ===
                
                // 1. Y轴完全同步 (修复空中掉落问题)
                // 让他悬停在和敌人同一高度，配合收刀
                this.y = enemy.y; 
                this.vy = 0; 
                this.inAir = false; 

                // 2. X轴智能落位 (背刺优先，撞墙则换位)
                // 计算敌人背后的位置。敌人朝右(1)，背后就是 x - 100；敌人朝左(-1)，背后是 x + 100。
                // 即：enemy.x - (enemy.dir * 100)
                let idealX = enemy.x - (enemy.dir * 100);
                
                // 3. 边界检测
                // 如果理想位置超出左墙(50) 或 超出右墙(W-90)
                if (idealX < 50 || idealX > W - 90) {
                    // 强制瞬移到敌人正面
                    idealX = enemy.x + (enemy.dir * 100);
                }
                
                this.x = idealX;
                
                // 4. 强制朝向敌人
                this.dir = (this.x < enemy.x) ? 1 : -1;
                
                // === v14 修复结束 ===
            }
        } else if (this.state === 'ult_end') {
            this.ultTimer++;
            // The Click moment
            if(this.ultTimer === 30) {
                AudioSys.sfx.ultBoom();
                shake = 40;
                flash = 10;
                timeScale = 1.0; // Resume time
                darkOverlay = 0;
                
                // Damage Logic
                let dmg = 150;
                enemy.takeDamage(dmg, -this.dir); // Knockback opposite to facing
                
                // Glass Shards
                for(let i=0; i<30; i++) {
                    particles.push(new Particle(enemy.x + enemy.w/2, enemy.y + enemy.h/2, '#00eaff', 15, 8, 40, 'shard'));
                }
                
                this.state = 'idle';
            }
        }
    }

    aiUpdate(target) {
        if(this.state === 'hit' || this.state === 'clash') return;
        
        let dist = Math.abs(this.x - target.x);
        
        // Simple AI
        if(dist > 80) {
            this.vx = 3 * (target.x > this.x ? 1 : -1);
            this.state = 'run';
        } else {
            this.vx = 0;
            this.state = 'idle';
            // Attack
            if(Math.random() < 0.05 && target.state !== 'dead') this.attack(target);
        }
        
        // AI Ult?
        if(this.mp >= 100 && dist < 200 && Math.random() < 0.01) this.performUlt(target);
    }

    attack(target) {
        if(this.state === 'attack' || this.state === 'hit' || this.state.startsWith('ult')) return;
        
        this.state = 'attack';
        this.animTimer = 0;
        this.vx = 8 * this.dir; // Lunge
        AudioSys.sfx.swing();
        
        // Hit detection delayed to sync with animation
        setTimeout(() => {
            if(this.state !== 'attack') return;
            
            // Box check
            let range = 100;
            let hit = Math.abs((this.x+this.w/2) - (target.x+target.w/2)) < range && Math.abs(this.y - target.y) < 80;
            
            if(hit) {
                // CLASH CHECK: If enemy is also attacking
                if(target.state === 'attack') {
                    this.clash(target);
                } else if (target.state !== 'ult_cast' && target.state !== 'ult_slash' && target.state !== 'dead') {
                    // Normal Hit
                    
                    // --- v15 UI Combo Logic Start ---
                    if(!this.isAi) { // 只有玩家产生连击数
                        uiCombo++;
                        const el = document.getElementById('combo-display');
                        el.innerText = uiCombo + " HITS";
                        el.style.opacity = 1;
                        el.style.transition = 'none'; // 移除过渡以瞬间变化
                        el.style.transform = "translateX(+50%) scale(1.5) rotate(-5deg)";
                        
                        // 强制重绘触发动画
                        void el.offsetWidth; 
                        
                        el.style.transition = 'transform 0.1s';
                        el.style.transform = "translateX(+50%) scale(1) rotate(0deg)";
                        
                        if(uiComboTimer) clearTimeout(uiComboTimer);
                        uiComboTimer = setTimeout(() => {
                            uiCombo = 0;
                            el.style.opacity = 0;
                        }, 2000); // 2秒断连
                    }
                    // --- v15 UI Combo Logic End ---
                    
                    timeScale = 0.1; setTimeout(()=>timeScale=1.0, 50); // Hitstop
                    shake = 10;
                    this.mp = Math.min(100, this.mp + 15);
                    target.takeDamage(15 + this.combo*5, this.dir);
                    this.combo = (this.combo+1)%3;
                }
            }
        }, 100 * (1/timeScale)); // Adjust for timescale? No, setTimeout runs on real time. 
        // Need to be careful with TimeScale interactions. For simple logic, use real time for timeout.
        
        setTimeout(() => { if(this.state==='attack') this.state='idle'; }, 300);
    }
    
    clash(enemy) {
        // Reset states
        this.state = 'clash'; enemy.state = 'clash';
        this.vx = -15 * this.dir; enemy.vx = -15 * enemy.dir; // Knockback
        
        shake = 20;
        AudioSys.sfx.clash();
        
        // VFX
        let midX = (this.x + enemy.x + this.w)/2;
        let midY = this.y + 40;
        for(let i=0; i<20; i++) particles.push(new Particle(midX, midY, '#fff', 10, 4, 20));
        
        const el = document.getElementById('clash-display');
        el.style.opacity = 1; el.style.transform = "scale(1.5)";
        setTimeout(()=> { el.style.opacity=0; el.style.transform="scale(1)"; }, 500);
        
        setTimeout(() => { 
            if(this.state==='clash') this.state='idle'; 
            if(enemy.state==='clash') enemy.state='idle'; 
        }, 300);
    }

	takeDamage(amt, hitDir) {
        // 修复点1：只有当我是攻击者(cast/slash)时才无敌。
        // 如果我是受害者(frozen)，我必须能挨打。
        if(this.state === 'dead' || (this.state.startsWith('ult') && this.state !== 'ult_frozen')) return;
        
        this.hp -= amt;
        // --- v15 Damage Text Start ---
        // 只有非大招定身状态才飘字，避免视觉混乱，或者你想任何时候都飘也可以
        damageTexts.push(new DamageText(this.x + this.w/2, this.y, amt, uiCombo > 3));
        // --- v15 Damage Text End ---
        this.state = 'hit'; // 修复点2：状态强制切回 hit，解除了 ult_frozen，AI 也就恢复了
        this.vx = 10 * hitDir;
        this.vy = -5;
        AudioSys.sfx.hit();
        
        // 粒子效果
        for(let i=0; i<5; i++) particles.push(new Particle(this.x+this.w/2, this.y+40, this.color, 8, 4, 20));

        if(this.hp <= 0) {
            this.hp = 0; 
            this.state = 'dead'; 
            this.vx = 15*hitDir; 
            this.vy = -10;
            // 修复点3：触发游戏结束
            endGame(this.isAi ? 'WIN' : 'LOSE');
        }
        // 受身恢复
        setTimeout(() => { if(this.state==='hit') this.state='idle'; }, 400);
    }

    performUlt(target) {
        if(this.mp < 100) return;
        this.mp = 0;
        this.state = 'ult_cast';
        this.ultTimer = 0;
        this.target = target;
        
        AudioSys.sfx.ultCast();
        
        // Global Effects
        timeScale = 0.05; // TIME STOP
        darkOverlay = 0.8;
        
        // Target Frozen
        target.state = 'ult_frozen';
        target.vx = 0; target.vy = 0;
    }

    draw(ctx) {
        // Invisibility during slash phase
        if(this.state === 'ult_slash') return;

        ctx.save();
        ctx.translate(this.x + this.w/2, this.y + this.h);
        ctx.scale(this.dir, 1);
        
        // Setup Glow
        ctx.strokeStyle = this.state==='dead' ? '#555' : this.color;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = this.state.startsWith('ult') ? 30 : 10;
        ctx.lineWidth = 4;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        // Hit flash
        if(this.state === 'hit') { ctx.strokeStyle = '#fff'; ctx.shadowBlur = 0; }

        // Stickman Drawing
        // Legs
        ctx.beginPath();
        if(this.state === 'jump' || this.inAir) {
            ctx.moveTo(-10, -40); ctx.lineTo(-20, -10);
            ctx.moveTo(10, -40); ctx.lineTo(20, -20);
        } else if (this.state === 'run') {
            let cycle = Math.sin(this.animTimer*0.5)*15;
            ctx.moveTo(-10, -40); ctx.lineTo(-20+cycle, 0);
            ctx.moveTo(10, -40); ctx.lineTo(20-cycle, 0);
        } else { // Idle
            ctx.moveTo(-10, -40); ctx.lineTo(-20, 0);
            ctx.moveTo(10, -40); ctx.lineTo(20, 0);
        }
        ctx.stroke();
        
        // Body
        ctx.fillRect(-15, -80, 30, 40);
        
        // Head
        ctx.beginPath(); ctx.arc(0, -90, 12, 0, Math.PI*2); ctx.fill();
        
        // Arms
        ctx.beginPath();
        if(this.state === 'attack') {
            ctx.moveTo(-10, -70); ctx.lineTo(-20, -40); // Back arm
            ctx.moveTo(10, -70); ctx.lineTo(40, -70); // Punch
        } else if (this.state === 'ult_cast' || this.state === 'ult_end') {
            // Sheath stance: hand on hip
            ctx.moveTo(-10, -70); ctx.lineTo(-30, -50); 
            ctx.moveTo(10, -70); ctx.lineTo(30, -50); 
            // Sword handle
            ctx.moveTo(-35, -55); ctx.lineTo(-50, -70);
        } else {
            let armS = this.state==='run' ? Math.sin(this.animTimer*0.5)*15 : 0;
            ctx.moveTo(-10, -70); ctx.lineTo(-20+armS, -30);
            ctx.moveTo(10, -70); ctx.lineTo(20-armS, -30);
        }
        ctx.stroke();
        
        ctx.restore();
    }
}

// Init Global Objects
let p1, p2;
let gameRunning = false;

// Input State
let input = {
    x: 0, // -1 to 1 slider
    attack: false,
    jump: false,
    ult: false
};

function endGame(result) {
    if(!gameRunning) return;
    // 慢动作结束
    timeScale = 0.1;
    setTimeout(() => { 
        gameRunning = false; // 暂停循环
        const overlay = document.getElementById('game-over-overlay');
        const title = document.getElementById('result-title');
        
        overlay.style.display = 'flex';
        if(result === 'WIN') {
            title.innerText = "VICTORY";
            title.className = "result-title win-text";
        } else {
            title.innerText = "DEFEAT";
            title.className = "result-title lose-text";
        }
    }, 3000); // 500ms 后显示结算
}

// 绑定重开按钮
document.getElementById('btn-restart').onclick = () => {
    document.getElementById('game-over-overlay').style.display = 'none';
    initGame(); // 重新初始化
};

function initGame() {
    // Reset Everything
    W = 1000; H = 600; // Logical Resolution
    canvas.width = W; canvas.height = H;
    
    p1 = new Fighter(200, '#00eaff', false);
    p2 = new Fighter(800, '#ff0055', true); // AI
    
    timeScale = 1.0;
    gameRunning = true;
    requestAnimationFrame(loop);
}

function updateCamera() {
    let tx, ty, tz;
    
    // 1. 基础数据计算
    let minX = Math.min(p1.x, p2.x);
    let maxX = Math.max(p1.x + p1.w, p2.x + p2.w);
    let minY = Math.min(p1.y, p2.y);
    let maxY = Math.max(p1.y + p1.h, p2.y + p2.h);
    let centerX = (minX + maxX) / 2;
    let centerY = (minY + maxY) / 2;
    let distW = maxX - minX;
    let distH = maxY - minY;
    
    // 2. 判断是否处于大招状态
    let ultUser = null;
    if(p1.state.startsWith('ult')) ultUser = p1;
    else if(p2.state.startsWith('ult')) ultUser = p2;

    // [更新位置]：增加 && ultUser.state !== 'ult_cast' 条件
    // 将“起手阶段”排除出分镜逻辑，仅在 乱斩(slash) 和 收刀(end) 时接管镜头
    if (ultUser && ultUser.state !== 'ult_cast') {
        
        // === v14 镜头分镜逻辑 ===
        
        if (ultUser.state === 'ult_slash') {
            // 分镜A：乱斩阶段 (Invisible) -> 特写受害者
            let victim = (ultUser === p1) ? p2 : p1;
            
            // 聚焦受害者中心
            tx = (victim.x + victim.w/2) - W/2;
            ty = (victim.y + victim.h/2);
            
            // 镜头拉近 (Zoom In) 感受压迫感
            tz = 1.3; 
            
        } else {
            // 分镜B：收刀/爆炸 (End) -> 广角构图框住两人
            // 注意：此时已排除了 Cast，所以这里的 else 仅对应 ult_end
            tx = centerX - W/2;
            ty = centerY; 
            
            let width = distW + 300; 
            tz = (W * 0.85) / width;
            tz = Math.min(Math.max(tz, 0.7), 1.5);
        }
        
    } else {
        // === 正常战斗逻辑 (保持 v12) ===
        // ult_cast 阶段也会落入这里，保持原本的平滑视距
        tx = centerX - W/2;
        ty = centerY; 
        
        let zoomX = W / (distW + 600); 
        let zoomY = H / (distH + 400); 
        tz = Math.min(zoomX, zoomY);
        tz = Math.min(Math.max(tz, 0.6), 1.3);
    }
    
    // 3. 平滑插值
    cam.x += (tx - cam.x) * 0.1;
    cam.y += (ty - cam.y) * 0.1;
    cam.zoom += (tz - cam.zoom) * 0.1;
}

function loop() {
    if(!gameRunning) return;
    requestAnimationFrame(loop);
    
    // 1. Logic Update
    p1.vx = input.x * 6; // Apply slider input
    if(input.jump && !p1.inAir) { p1.vy = -20; p1.state='jump'; AudioSys.sfx.jump(); input.jump = false; }
    if(input.attack) { p1.attack(p2); input.attack = false; }
    if(input.ult) { p1.performUlt(p2); input.ult = false; }
    
    p1.update(1, p2);
    p2.update(1, p1);
    
    updateCamera();
    
    // UI Update
    document.getElementById('p1-hp').style.width = (p1.hp/p1.maxHp*100)+'%';
    document.getElementById('p1-mp').style.width = p1.mp+'%';
    document.getElementById('p2-hp').style.width = (p2.hp/p2.maxHp*100)+'%';
    document.getElementById('p2-mp').style.width = p2.mp+'%';
    
    // 2. Rendering
    ctx.clearRect(0,0,W,H);
    ctx.save();
    
    // Shake
    let dx = (Math.random()-0.5)*shake;
    let dy = (Math.random()-0.5)*shake;
    if(shake>0) shake *= 0.9;
    
    // Apply Camera
    ctx.translate(W/2, H/2); // Center pivot
    ctx.scale(cam.zoom, cam.zoom);
    ctx.translate(-W/2 - cam.x + dx, -cam.y + dy);
    
    // Background (Parallax)
    // Far City
    ctx.fillStyle = '#111';
    for(let i=-5; i<15; i++) {
        let h = 300 + Math.sin(i*132)*100;
        ctx.fillRect(i*200 - (cam.x*0.2), H-100-h, 120, h);
        // Neon windows
        ctx.fillStyle = i%3==0 ? '#222' : (i%2==0 ? '#301111' : '#113030');
        ctx.fillRect(i*200 - (cam.x*0.2) + 10, H-100-h+20, 100, 10);
        ctx.fillStyle = '#111';
    }
    
    // Floor
    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(-1000, H-100, W+2000, 400);
    ctx.strokeStyle = '#00eaff'; ctx.lineWidth = 2; ctx.globalAlpha = 0.3;
    ctx.beginPath(); ctx.moveTo(-1000, H-100); ctx.lineTo(W+2000, H-100); ctx.stroke();
    ctx.globalAlpha = 1;
	
	// 在 loop 函数中，画完地板后，画角色前：
    ctx.fillStyle = '#333';
    ctx.strokeStyle = '#00eaff';
    ctx.lineWidth = 2;
    for(let p of platforms) {
        ctx.fillRect(p.x, p.y, p.w, p.h);
        ctx.strokeRect(p.x, p.y, p.w, p.h);
        // 简单的霓虹边框光效
        ctx.save();
        ctx.shadowColor = '#00eaff'; ctx.shadowBlur = 10;
        ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x+p.w, p.y); ctx.stroke();
        ctx.restore();
    }
    
    // Dark Overlay for Ult
    if(darkOverlay > 0) {
        ctx.fillStyle = `rgba(0,0,0,${darkOverlay})`;
        // We need to cover the whole world, not just screen
        ctx.fillRect(cam.x - 1000, -1000, W+2000, H+2000);
    }
    
    // Draw Fighters
    p1.draw(ctx);
    p2.draw(ctx);
    
    // Ult Slash Lines (The "Dimension Cut" VFX)
    if(slashLines.length > 0) {
        ctx.save();
        ctx.shadowBlur = 10; ctx.shadowColor = '#fff'; ctx.strokeStyle = '#fff'; ctx.lineWidth = 3;
        for(let i=slashLines.length-1; i>=0; i--) {
            let line = slashLines[i];
            if(line.delay > 0) { line.delay -= 1; continue; }
            
            line.life--;
            ctx.globalAlpha = line.life / 10;
            ctx.beginPath();
            let halfLen = line.len / 2;
            let cx = Math.cos(line.angle), cy = Math.sin(line.angle);
            ctx.moveTo(line.x - cx*halfLen, line.y - cy*halfLen);
            ctx.lineTo(line.x + cx*halfLen, line.y + cy*halfLen);
            ctx.stroke();
            
            if(line.life <= 0) slashLines.splice(i, 1);
        }
        ctx.restore();
    }
    
    // Damage Texts (World Space)
    for(let i=damageTexts.length-1; i>=0; i--) {
        damageTexts[i].update();
        damageTexts[i].draw(ctx);
        if(damageTexts[i].life <= 0) damageTexts.splice(i, 1);
    }
    
    // Particles
    for(let i=particles.length-1; i>=0; i--) {
        particles[i].update();
        particles[i].draw(ctx);
        if(particles[i].life<=0) particles.splice(i,1);
    }
    
    ctx.restore();

    // Screen Flash
    if(flash > 0) {
        ctx.fillStyle = `rgba(255,255,255,${flash/10})`;
        ctx.fillRect(0,0,W,H);
        flash--;
    }
}

/**
 * INPUT HANDLING (Gestures & Sliders)
 */
// Start Button
document.getElementById('btn-start').onclick = async () => {
    AudioSys.init();
    const docEl = document.documentElement;
    
    // Try Fullscreen
    if(docEl.requestFullscreen) await docEl.requestFullscreen();
    else if(docEl.webkitRequestFullscreen) await docEl.webkitRequestFullscreen();
    
    // Try Lock Orientation
    if(screen.orientation && screen.orientation.lock) {
        try { await screen.orientation.lock('landscape'); } catch(e){ console.log('Lock failed, using CSS fallback'); }
    }
    
    // Check orientation and apply CSS fix if needed
    checkOrientation();
    window.addEventListener('resize', checkOrientation);
    
    document.getElementById('start-overlay').style.display = 'none';
    
    // Show controls on touch devices (simple check)
    if('ontouchstart' in window || navigator.maxTouchPoints > 0) {
        document.getElementById('controls-layer').style.display = 'block';
    }
    
    initGame();
};

function checkOrientation() {
    // If height > width, we are in portrait. Force rotate.
    if(window.innerHeight > window.innerWidth) {
        container.classList.add('force-landscape');
    } else {
        container.classList.remove('force-landscape');
    }
}

// Joystick Logic
const stickTrack = document.getElementById('stick-track');
const stickThumb = document.getElementById('stick-thumb');
let stickTouchId = null;
let stickCenter = 0;

stickTrack.addEventListener('touchstart', e => {
    e.preventDefault();
    const t = e.changedTouches[0];
    stickTouchId = t.identifier;
    const rect = stickTrack.getBoundingClientRect();
    stickCenter = rect.left + rect.width/2;
    updateStick(t.clientX);
}, {passive:false});

stickTrack.addEventListener('touchmove', e => {
    e.preventDefault();
    for(let i=0; i<e.changedTouches.length; i++) {
        if(e.changedTouches[i].identifier === stickTouchId) {
            updateStick(e.changedTouches[i].clientX);
        }
    }
}, {passive:false});

const endStick = (e) => {
    for(let i=0; i<e.changedTouches.length; i++) {
        if(e.changedTouches[i].identifier === stickTouchId) {
            stickTouchId = null;
            input.x = 0;
            stickThumb.style.transform = `translateX(0px)`;
        }
    }
};
stickTrack.addEventListener('touchend', endStick);
stickTrack.addEventListener('touchcancel', endStick);

function updateStick(clientX) {
    // Correct clientX if rotated!
    // If rotated, the X axis of visual screen is Y axis of touch... 
    // This is tricky. Let's rely on logic coordinates relative to element, which usually updates.
    // Actually, if we use CSS transform rotate on container, touch coordinates might need remapping.
    // SIMPLE FIX: Use the bounding client rect of the track, which reflects the rotation.
    
    const rect = stickTrack.getBoundingClientRect();
    let val;
    
    // Determine orientation context
    if(container.classList.contains('force-landscape')) {
        // In visual landscape (physical portrait), Track X is actually Physical Y axis mostly
        // But getBoundingClientRect handles the transform box. 
        // Let's simpler approach: Calculate offset from center of the rect.
        const cx = rect.left + rect.width/2;
        const cy = rect.top + rect.height/2;
        // Since stick is horizontal in game space...
        // In normal landscape: delta is x.
        // In forced landscape (rotated 90deg): delta is y? No, the element is rotated.
        // Let's try standard calculation first, stickTrack is inside game-container.
        
        // Wait, if container is rotated 90deg, 'left' becomes 'top' visually.
        // Let's just trust browser mapping of element coordinates.
        // We compare touch point to element center.
    }
    
    // Robust method:
    const cx = rect.left + rect.width/2;
    const cy = rect.top + rect.height/2;
    
    // We assume the track is horizontal in visual space.
    // If forced landscape (rotated), the track is vertical in physical space.
    let delta = 0;
    if(container.classList.contains('force-landscape')) {
        delta = clientX - cx; // Actually for rotated 90deg, X becomes Y... 
        // Let's assume user taps "visually left/right".
        // If rotated 90deg clockwise: Visual Right is Physical Down. Visual Left is Physical Up.
        // Stick track visual width is Physical Height.
        // Too complex to map perfectly without testing device.
        // FALLBACK: Just use X offset relative to rect center, works 90% cases unless fully orthogonal.
        // Actually, let's use the delta projected onto the track's axis.
        
        // Assume standard case first for code brevity, refine if user complains.
        // For forced rotation, usually clientY matters.
        delta = (window.innerHeight > window.innerWidth) ? (e.changedTouches[0].clientY - cy) : (clientX - cx);
    } 
    
    // Simplified:
    // Just map relative to center. Max range 60px.
    // We need to know if we are checking X or Y based on rotation.
    let isRotated = container.classList.contains('force-landscape');
    let pos = isRotated ? arguments[0] /* wait, need Y */ : clientX;
    
    // Re-getting touch for Y if needed is hard here structure wise.
    // Let's just standard mapping. If it fails on rotated, the slider might feel weird but work.
    let d = clientX - (rect.left + rect.width/2);
    
    // Special fix for rotated input
    if(isRotated) {
        // In rotated mode, visual X is physical Y
        // But we passed clientX. We need clientY from the event really.
        // Due to structure limits, let's just stick to standard X. 
        // Note: CSS rotate transforms visual, but touch coordinates remain screen space.
        // If visual is rotated, user drags finger along physical Y axis to move "visual X".
        // So we should read clientY.
        // *Self-Correction*: The listener passes clientX. I need to change listener to pass event.
    }
    
    // Standard calc
    let max = 60;
    d = Math.max(-max, Math.min(max, d));
    input.x = d / max;
    stickThumb.style.transform = `translateX(${d}px)`;
}

// Fix Stick for Rotation (Overwrite listener logic slightly)
stickTrack.removeEventListener('touchmove', null); // Clear old
stickTrack.addEventListener('touchmove', e => {
    e.preventDefault();
    for(let i=0; i<e.changedTouches.length; i++) {
        if(e.changedTouches[i].identifier === stickTouchId) {
            let t = e.changedTouches[i];
            let rect = stickTrack.getBoundingClientRect();
            let isRot = container.classList.contains('force-landscape');
            let delta = 0;
            
            if(isRot) {
                // Visual Left/Right is Physical Top/Bottom (or Bottom/Top)
                // Rotate 90deg: Top is Left.
                let cy = rect.top + rect.height/2;
                delta = t.clientY - cy; 
            } else {
                let cx = rect.left + rect.width/2;
                delta = t.clientX - cx;
            }
            
            let max = 60;
            delta = Math.max(-max, Math.min(max, delta));
            input.x = delta / max;
            stickThumb.style.transform = `translateX(${delta}px)`;
        }
    }
}, {passive:false});


// Gesture Logic
const gesturePad = document.getElementById('gesture-pad');
let gStart = {x:0, y:0, time:0};

gesturePad.addEventListener('touchstart', e => {
    e.preventDefault();
    let t = e.changedTouches[0];
    gStart = {x: t.clientX, y: t.clientY, time: Date.now()};
}, {passive:false});

gesturePad.addEventListener('touchend', e => {
    e.preventDefault();
    let t = e.changedTouches[0];
    let dx = t.clientX - gStart.x;
    let dy = t.clientY - gStart.y;
    let dt = Date.now() - gStart.time;
    
    // Rotation mapping
    if(container.classList.contains('force-landscape')) {
        // Visual Up is Physical Left (dx < 0)
        // Visual Down is Physical Right (dx > 0)
        let temp = dx; dx = dy; dy = -temp; // 90deg mapping approx
    }

    if(dt < 300) {
        if(Math.abs(dx) < 30 && Math.abs(dy) < 30) {
            // Tap
            input.attack = true;
        } else if (dy < -50) {
            // Swipe Up
            input.jump = true;
        } else if (dy > 50) {
            // Swipe Down
            input.ult = true;
        }
    }
}, {passive:false});

// Keyboard Fallback
window.addEventListener('keydown', e => {
    if(e.key==='a') input.x = -1;
    if(e.key==='d') input.x = 1;
    if(e.key==='w') input.jump = true;
    if(e.key==='j') input.attack = true;
    if(e.key==='k') input.ult = true;
});
window.addEventListener('keyup', e => {
    if(e.key==='a' || e.key==='d') input.x = 0;
});

</script>
</body>
</html>