diff --git a/versions/code_15.html b/versions/code_15.html
index 9931ae0..35df21b 100644
--- a/versions/code_15.html
+++ b/versions/code_15.html
@@ -48,19 +48,44 @@
         /* 虚拟控制器 (仅触摸屏显示) */
         #controls-layer { position: absolute; inset: 0; pointer-events: none; z-index: 10; display: none; }
         
-        /* 左侧摇杆槽 */
-        .joystick-track { 
-            position: absolute; bottom: 40px; left: 40px; width: 200px; height: 60px; 
-            background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2); 
-            border-radius: 30px; pointer-events: auto; backdrop-filter: blur(4px);
-            display: flex; align-items: center; justify-content: center;
-        }
-        .joystick-thumb {
-            width: 80px; height: 50px; background: rgba(0, 234, 255, 0.3); border: 2px solid #00eaff; 
-            border-radius: 25px; box-shadow: 0 0 15px #00eaff; transform: translateX(0);
-        }
-        .joy-label { position: absolute; top: -30px; left: 0; color: #aaa; font-size: 12px; width: 100%; text-align: center; }
-
+        /* v16 八向罗盘摇杆样式 */
+	    .joystick-base {
+	        position: absolute; bottom: 40px; left: 40px; width: 160px; height: 160px;
+	        border-radius: 50%; border: 2px solid rgba(0, 234, 255, 0.3);
+	        background: rgba(0,0,0,0.5); pointer-events: auto;
+	        display: flex; align-items: center; justify-content: center;
+	    }
+	    .joy-lines, .joy-slots { position: absolute; inset: 0; pointer-events: none; }
+	    
+	    /* 连线 */
+	    .joy-line {
+	        position: absolute; top: 50%; left: 50%; width: 50%; height: 2px;
+	        background: rgba(255,255,255,0.1); transform-origin: 0 50%;
+	        transform: rotate(calc(var(--i) * 45deg));
+	        transition: background 0.1s;
+	    }
+	    /* 宝石槽 */
+	    .joy-slot {
+	        position: absolute; top: 50%; left: 50%; width: 12px; height: 12px;
+	        margin-top: -6px; margin-left: 70px; /* 半径距离 */
+	        background: rgba(0,0,0,0.8); border: 1px solid #555; border-radius: 50%;
+	        transform-origin: -70px 50%; /* 绕圆心旋转 */
+	        transform: rotate(calc(var(--i) * 45deg));
+	        box-shadow: 0 0 5px #000; transition: all 0.1s;
+	    }
+	    
+	    /* 激活状态高亮 */
+	    .joy-line.active { background: #00eaff; box-shadow: 0 0 10px #00eaff; height: 3px; }
+	    .joy-slot.active { background: #fff; border-color: #00eaff; box-shadow: 0 0 15px #00eaff; transform: rotate(calc(var(--i) * 45deg)) scale(1.5); }
+	    
+	    /* 摇杆头 */
+	    .joystick-thumb {
+	        position: absolute; width: 60px; height: 60px;
+	        background: rgba(0, 234, 255, 0.2); border: 2px solid #00eaff;
+	        border-radius: 50%; box-shadow: 0 0 15px #00eaff;
+	        transition: transform 0.05s;
+	    }
+	    
         /* 右侧手势区 */
         .gesture-zone {
             position: absolute; bottom: 0; right: 0; width: 50%; height: 100%;
@@ -144,10 +169,22 @@
 
     <!-- 触摸控制器 -->
     <div id="controls-layer">
-        <div class="joystick-track" id="stick-track">
-            <div class="joy-label">&lt; MOVE &gt;</div>
-            <div class="joystick-thumb" id="stick-thumb"></div>
-        </div>
+	    <div class="joystick-base" id="stick-base">
+	        <!-- 动态生成的8向槽位结构将由CSS控制布局 -->
+	        <div class="joy-lines">
+	            <div class="joy-line" style="--i:0"></div><div class="joy-line" style="--i:1"></div>
+	            <div class="joy-line" style="--i:2"></div><div class="joy-line" style="--i:3"></div>
+	            <div class="joy-line" style="--i:4"></div><div class="joy-line" style="--i:5"></div>
+	            <div class="joy-line" style="--i:6"></div><div class="joy-line" style="--i:7"></div>
+	        </div>
+	        <div class="joy-slots">
+	            <div class="joy-slot" style="--i:0"></div><div class="joy-slot" style="--i:1"></div>
+	            <div class="joy-slot" style="--i:2"></div><div class="joy-slot" style="--i:3"></div>
+	            <div class="joy-slot" style="--i:4"></div><div class="joy-slot" style="--i:5"></div>
+	            <div class="joy-slot" style="--i:6"></div><div class="joy-slot" style="--i:7"></div>
+	        </div>
+	        <div class="joystick-thumb" id="stick-thumb"></div>
+    	</div>
         <div class="gesture-zone" id="gesture-pad">
             <div class="gesture-hint">
                 TAP : ATTACK<br>
@@ -269,6 +306,43 @@ class Particle {
     }
 }
 
+let lightningTrails = [];
+class LightningTrail {
+    constructor(x1, y1, x2, y2) {
+        this.path = [];
+        this.timer = 15; // 存活帧数
+        // 生成折线路径
+        let steps = 10;
+        let dx = (x2-x1)/steps;
+        let dy = (y2-y1)/steps;
+        this.path.push({x:x1, y:y1});
+        for(let i=1; i<steps; i++) {
+            let jitter = (Math.random()-0.5) * 40;
+            this.path.push({x: x1 + dx*i, y: y1 + dy*i + jitter});
+        }
+        this.path.push({x:x2, y:y2});
+    }
+    draw(ctx) {
+        if(this.timer <= 0) return;
+        ctx.save();
+        ctx.beginPath();
+        ctx.moveTo(this.path[0].x, this.path[0].y);
+        for(let p of this.path) ctx.lineTo(p.x, p.y);
+        
+        // 爆裂阶段 (Bloom)
+        let bloom = this.timer < 5;
+        ctx.lineWidth = bloom ? 6 : 3;
+        ctx.strokeStyle = bloom ? '#fff' : '#00eaff';
+        ctx.shadowColor = '#00eaff';
+        ctx.shadowBlur = bloom ? 40 : 15;
+        
+        ctx.globalAlpha = this.timer / 15;
+        ctx.stroke();
+        ctx.restore();
+        this.timer--;
+    }
+}
+
 let damageTexts = []; // 伤害飘字数组
 let uiCombo = 0;      // UI连击计数
 let uiComboTimer = null;
@@ -328,6 +402,91 @@ class Fighter {
         if(this.isAi && this.state !== 'dead' && this.state !== 'ult_frozen') {
             this.aiUpdate(enemy);
         }
+        
+        // --- v16 Move Logic Update ---
+    
+	    // 判定闪刀触发: 摇杆在下方 (270° ± 22.5 => 247.5~292.5) 且 收到冲刺指令
+	    let isCrouchInput = input.angle > 247.5 && input.angle < 292.5 && input.y < -0.3; 
+	    
+	    // 状态机入口
+	    if(input.dash > 0 && this.state !== 'dash' && this.state !== 'flash_slash' && !this.state.startsWith('ult')) {
+	        let dashDir = (input.dash === 1) ? -1 : 1;
+	        this.dir = dashDir; // 强制转身
+	        
+	        if(isCrouchInput) {
+	            // ---> 触发 闪刀 (Flash Slash)
+	            this.state = 'flash_slash';
+	            this.animTimer = 0;
+	            this.vx = 0; 
+	            this.flashTargetX = this.x + (350 * this.dir); // 穿透目标点
+	        } else {
+	            // ---> 触发 普通冲刺 (Dash)
+	            this.state = 'dash';
+	            this.animTimer = 0;
+	            this.vx = 25 * this.dir; 
+	            AudioSys.noise(0.1, 0.1); // Woosh sound
+	        }
+	        input.dash = 0; // 消耗指令
+	    }
+	    
+	    // 状态机逻辑
+	    if(this.state === 'dash') {
+	        this.animTimer++;
+	        this.vy = 0; // 重力无效
+	        // 产生残影粒子
+	        if(this.animTimer % 2 === 0) {
+	            particles.push(new Particle(this.x+this.w/2, this.y+this.h/2, this.color, 0, 30, 10));
+	        }
+	        if(this.animTimer > 10) { this.state = 'idle'; this.vx = 0; }
+	        return; // 跳过后续物理
+	    }
+	    
+	    if(this.state === 'flash_slash') {
+	        this.animTimer++;
+	        this.vy = 0; this.vx = 0; // 锁定位置
+	        
+	        // Phase 1: Charge (0-5帧)
+	        if(this.animTimer === 1) {
+	            // 白闪蓄力
+	            particles.push(new Particle(this.x+this.w/2, this.y+this.h/2, '#fff', 2, 80, 5)); 
+	        }
+	        
+	        // Phase 2: Teleport & Trail (第6帧)
+	        if(this.animTimer === 6) {
+	            let startX = this.x + this.w/2;
+	            let startY = this.y + this.h/2;
+	            
+	            this.x = this.flashTargetX; // 瞬移
+	            // 边界修正
+	            if(this.x < 0) this.x = 0;
+	            if(this.x > W-40) this.x = W-40;
+	            
+	            let endX = this.x + this.w/2;
+	            // 生成滞留闪电
+	            lightningTrails.push(new LightningTrail(startX, startY, endX, startY));
+	            AudioSys.playTone(600, 'sawtooth', 0.1, 0.2, 2000); // Zap sound
+	        }
+	        
+	        // Phase 3: Bloom & Damage (第18帧)
+	        if(this.animTimer === 18) {
+	            AudioSys.noise(0.3, 0.5); // Thunder boom
+	            shake = 15;
+	            
+	            // 伤害判定 (对路径上的敌人)
+	            // 简单判定：如果在闪刀起点和终点之间
+	            let minX = Math.min(this.x, this.flashTargetX);
+	            let maxX = Math.max(this.x, this.flashTargetX);
+	            if(enemy.x + enemy.w > minX && enemy.x < maxX && Math.abs(enemy.y - this.y) < 100) {
+	                enemy.takeDamage(40, this.dir); // 闪刀伤害
+	                // 必爆连击
+	                uiCombo++; // 增加连击数
+	            }
+	        }
+	        
+	        if(this.animTimer > 25) this.state = 'idle';
+	        return; // 跳过后续物理
+	    }
+	    // --- v16 End ---
 
         // Physics
         this.vy += 0.8 * timeScale; // Gravity
@@ -575,6 +734,10 @@ class Fighter {
     }
 
 	takeDamage(amt, hitDir) {
+		// [v16 更新] 增加 dash 和 flash_slash 的无敌判定
+        if(this.state === 'dead' || this.state === 'dash' || this.state === 'flash_slash' || 
+          (this.state.startsWith('ult') && this.state !== 'ult_frozen')) return;
+          
         // 修复点1：只有当我是攻击者(cast/slash)时才无敌。
         // 如果我是受害者(frozen)，我必须能挨打。
         if(this.state === 'dead' || (this.state.startsWith('ult') && this.state !== 'ult_frozen')) return;
@@ -691,10 +854,11 @@ let gameRunning = false;
 
 // Input State
 let input = {
-    x: 0, // -1 to 1 slider
-    attack: false,
-    jump: false,
-    ult: false
+    x: 0, 
+    y: 0, // 新增 Y轴
+    angle: 0, // 新增 角度 (0-360)
+    attack: false, jump: false, ult: false, 
+    dash: 0 // 0:无, 1:左冲, 2:右冲
 };
 
 function endGame(result) {
@@ -879,6 +1043,12 @@ function loop() {
     p1.draw(ctx);
     p2.draw(ctx);
     
+    // Draw Lightning Trails (v16)
+	for(let i=lightningTrails.length-1; i>=0; i--) {
+	    lightningTrails[i].draw(ctx);
+	    if(lightningTrails[i].timer<=0) lightningTrails.splice(i,1);
+	}
+    
     // Ult Slash Lines (The "Dimension Cut" VFX)
     if(slashLines.length > 0) {
         ctx.save();
@@ -965,116 +1135,80 @@ function checkOrientation() {
     }
 }
 
-// Joystick Logic
-const stickTrack = document.getElementById('stick-track');
+// --- v16 New Joystick Logic ---
+const stickBase = document.getElementById('stick-base');
 const stickThumb = document.getElementById('stick-thumb');
+const lines = document.querySelectorAll('.joy-line');
+const slots = document.querySelectorAll('.joy-slot');
 let stickTouchId = null;
-let stickCenter = 0;
 
-stickTrack.addEventListener('touchstart', e => {
+stickBase.addEventListener('touchstart', e => {
     e.preventDefault();
-    const t = e.changedTouches[0];
-    stickTouchId = t.identifier;
-    const rect = stickTrack.getBoundingClientRect();
-    stickCenter = rect.left + rect.width/2;
-    updateStick(t.clientX);
+    stickTouchId = e.changedTouches[0].identifier;
+    updateStick(e.changedTouches[0]);
 }, {passive:false});
 
-stickTrack.addEventListener('touchmove', e => {
+stickBase.addEventListener('touchmove', e => {
     e.preventDefault();
     for(let i=0; i<e.changedTouches.length; i++) {
-        if(e.changedTouches[i].identifier === stickTouchId) {
-            updateStick(e.changedTouches[i].clientX);
-        }
+        if(e.changedTouches[i].identifier === stickTouchId) updateStick(e.changedTouches[i]);
     }
 }, {passive:false});
 
-const endStick = (e) => {
+const resetStick = (e) => {
     for(let i=0; i<e.changedTouches.length; i++) {
         if(e.changedTouches[i].identifier === stickTouchId) {
             stickTouchId = null;
-            input.x = 0;
-            stickThumb.style.transform = `translateX(0px)`;
+            input.x = 0; input.y = 0;
+            stickThumb.style.transform = `translate(0px, 0px)`;
+            // 清除高亮
+            lines.forEach(l => l.classList.remove('active'));
+            slots.forEach(s => s.classList.remove('active'));
         }
     }
 };
-stickTrack.addEventListener('touchend', endStick);
-stickTrack.addEventListener('touchcancel', endStick);
+stickBase.addEventListener('touchend', resetStick);
 
-function updateStick(clientX) {
-    // Correct clientX if rotated!
-    // If rotated, the X axis of visual screen is Y axis of touch... 
-    // This is tricky. Let's rely on logic coordinates relative to element, which usually updates.
-    // Actually, if we use CSS transform rotate on container, touch coordinates might need remapping.
-    // SIMPLE FIX: Use the bounding client rect of the track, which reflects the rotation.
+function updateStick(touch) {
+    const rect = stickBase.getBoundingClientRect();
+    const cx = rect.left + rect.width/2;
+    const cy = rect.top + rect.height/2;
     
-    const rect = stickTrack.getBoundingClientRect();
-    let val;
+    let dx = touch.clientX - cx;
+    let dy = touch.clientY - cy;
     
-    // Determine orientation context
-    if(container.classList.contains('force-landscape')) {
-        // In visual landscape (physical portrait), Track X is actually Physical Y axis mostly
-        // But getBoundingClientRect handles the transform box. 
-        // Let's simpler approach: Calculate offset from center of the rect.
-        const cx = rect.left + rect.width/2;
-        const cy = rect.top + rect.height/2;
-        // Since stick is horizontal in game space...
-        // In normal landscape: delta is x.
-        // In forced landscape (rotated 90deg): delta is y? No, the element is rotated.
-        // Let's try standard calculation first, stickTrack is inside game-container.
-        
-        // Wait, if container is rotated 90deg, 'left' becomes 'top' visually.
-        // Let's just trust browser mapping of element coordinates.
-        // We compare touch point to element center.
-    }
+    // 1. 距离限制
+    const maxDist = 60;
+    const dist = Math.sqrt(dx*dx + dy*dy);
+    const scale = Math.min(dist, maxDist);
+    const angleRad = Math.atan2(dy, dx); // 物理屏幕角度
     
-    // Robust method:
-    const cx = rect.left + rect.width/2;
-    const cy = rect.top + rect.height/2;
+    const tx = Math.cos(angleRad) * scale;
+    const ty = Math.sin(angleRad) * scale;
+    stickThumb.style.transform = `translate(${tx}px, ${ty}px)`;
     
-    // We assume the track is horizontal in visual space.
-    // If forced landscape (rotated), the track is vertical in physical space.
-    let delta = 0;
-    if(container.classList.contains('force-landscape')) {
-        delta = clientX - cx; // Actually for rotated 90deg, X becomes Y... 
-        // Let's assume user taps "visually left/right".
-        // If rotated 90deg clockwise: Visual Right is Physical Down. Visual Left is Physical Up.
-        // Stick track visual width is Physical Height.
-        // Too complex to map perfectly without testing device.
-        // FALLBACK: Just use X offset relative to rect center, works 90% cases unless fully orthogonal.
-        // Actually, let's use the delta projected onto the track's axis.
-        
-        // Assume standard case first for code brevity, refine if user complains.
-        // For forced rotation, usually clientY matters.
-        delta = (window.innerHeight > window.innerWidth) ? (e.changedTouches[0].clientY - cy) : (clientX - cx);
-    } 
+    // 2. 逻辑映射 (标准坐标系: Y向上为正, X向右为正)
+    // 屏幕坐标系 Y向下。所以 MathY = -ScreenY
+    let mathAngle = Math.atan2(-dy, dx) * (180/Math.PI); 
+    if(mathAngle < 0) mathAngle += 360; // 0-360 CCW
     
-    // Simplified:
-    // Just map relative to center. Max range 60px.
-    // We need to know if we are checking X or Y based on rotation.
-    let isRotated = container.classList.contains('force-landscape');
-    let pos = isRotated ? arguments[0] /* wait, need Y */ : clientX;
+    input.angle = mathAngle;
+    input.x = tx / maxDist;
+    input.y = -ty / maxDist; // input.y > 0 表示向上推
     
-    // Re-getting touch for Y if needed is hard here structure wise.
-    // Let's just standard mapping. If it fails on rotated, the slider might feel weird but work.
-    let d = clientX - (rect.left + rect.width/2);
+    // 3. 视觉高亮 (Sector Calculation)
+    // 0°(Right) is index 0. 45° is index 1...
+    // 偏移 22.5度以居中扇区
+    let sector = Math.round(mathAngle / 45) % 8;
     
-    // Special fix for rotated input
-    if(isRotated) {
-        // In rotated mode, visual X is physical Y
-        // But we passed clientX. We need clientY from the event really.
-        // Due to structure limits, let's just stick to standard X. 
-        // Note: CSS rotate transforms visual, but touch coordinates remain screen space.
-        // If visual is rotated, user drags finger along physical Y axis to move "visual X".
-        // So we should read clientY.
-        // *Self-Correction*: The listener passes clientX. I need to change listener to pass event.
-    }
+    lines.forEach(l => l.classList.remove('active'));
+    slots.forEach(s => s.classList.remove('active'));
     
-    // Standard calc
-    let max = 60;
-    d = Math.max(-max, Math.min(max, d));
-    input.x = d / max;
-    stickThumb.style.transform = `translateX(${d}px)`;
+    // 仅当推杆有一定力度时才点亮
+    if(dist > 20) {
+        lines[sector].classList.add('active');
+        slots[sector].classList.add('active');
+    }
 }
 
 // Fix Stick for Rotation (Overwrite listener logic slightly)
@@ -1107,16 +1241,7 @@ stickTrack.addEventListener('touchmove', e => {
 }, {passive:false});
 
 
-// Gesture Logic
-const gesturePad = document.getElementById('gesture-pad');
-let gStart = {x:0, y:0, time:0};
-
-gesturePad.addEventListener('touchstart', e => {
-    e.preventDefault();
-    let t = e.changedTouches[0];
-    gStart = {x: t.clientX, y: t.clientY, time: Date.now()};
-}, {passive:false});
-
+// --- v16 Gesture Logic ---
 gesturePad.addEventListener('touchend', e => {
     e.preventDefault();
     let t = e.changedTouches[0];
@@ -1124,23 +1249,27 @@ gesturePad.addEventListener('touchend', e => {
     let dy = t.clientY - gStart.y;
     let dt = Date.now() - gStart.time;
     
-    // Rotation mapping
+    // 横屏修正 (如果使用了 CSS 强制旋转)
     if(container.classList.contains('force-landscape')) {
-        // Visual Up is Physical Left (dx < 0)
-        // Visual Down is Physical Right (dx > 0)
-        let temp = dx; dx = dy; dy = -temp; // 90deg mapping approx
+        let temp = dx; dx = dy; dy = -temp; 
     }
 
     if(dt < 300) {
-        if(Math.abs(dx) < 30 && Math.abs(dy) < 30) {
-            // Tap
-            input.attack = true;
-        } else if (dy < -50) {
-            // Swipe Up
-            input.jump = true;
-        } else if (dy > 50) {
-            // Swipe Down
-            input.ult = true;
+        let absDx = Math.abs(dx);
+        let absDy = Math.abs(dy);
+        
+        if(absDx < 30 && absDy < 30) {
+            input.attack = true; // TAP
+        } else if (absDy > absDx) {
+            // Vertical Swipes
+            if(dy < -50) input.jump = true; // UP
+            else if (dy > 50) input.ult = true; // DOWN
+        } else {
+            // Horizontal Swipes (New for v16)
+            if(absDx > 50) {
+                // 1 = Left Dash, 2 = Right Dash
+                input.dash = dx < 0 ? 1 : 2; 
+            }
         }
     }
 }, {passive:false});
