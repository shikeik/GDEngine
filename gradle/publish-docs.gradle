// æ–‡ä»¶: gradle/publish-docs.gradle
import java.security.MessageDigest
import groovy.json.JsonOutput

// ============================================================
// æ–‡æ¡£å‘å¸ƒæµæ°´çº¿ (Production Pipeline)
// 1. Zip -> 2. Split -> 3. Manifest -> 4. Dist
// ============================================================

ext {
	CHUNK_SIZE = 18 * 1024 * 1024 // 18 MB (ç•™2MBå®‰å…¨ä½™é‡ç»™JsDelivr)
	DOCS_ROOT = file("docs")      // æºç›®å½•çš„çˆ¶çº§
	BUILD_TMP = file("build/tmp_publish")
	DIST_DIR = file("dist")       // æœ€ç»ˆäº§ç‰©ç›®å½• (éœ€æäº¤åˆ°Git)
}

// æ­¥éª¤ 1: æ‰“åŒ… (ä¿ç•™ç›®å½•ç»“æž„ engine_docs/...)
tasks.register('packageDocs', Zip) {
	group = 'gdengine-publish'
	description = 'Step 1: Package engine_docs into a single zip'

	// ä»Ž docs ç›®å½•æ‰“åŒ…ï¼ŒåŒ…å« engine_docs æ–‡ä»¶å¤¹æœ¬èº«
	from DOCS_ROOT
	include 'engine_docs/**'

	archiveFileName = 'docs_full.zip'
	destinationDirectory = BUILD_TMP

	doFirst {
		BUILD_TMP.mkdirs()
	}
}

// æ­¥éª¤ 2 & 3: åˆ‡åˆ†ä¸Žç”Ÿæˆæ¸…å•
tasks.register('buildDocsDist') {
	group = 'gdengine-publish'
	description = 'Step 2: Split zip and generate manifest.json'
	dependsOn 'packageDocs'
	
	// [æ ¸å¿ƒä¿®å¤] å¼ºåˆ¶ä»»åŠ¡æ¯æ¬¡éƒ½æ‰§è¡Œï¼Œä¸ä½¿ç”¨ç¼“å­˜
    // è¿™æ ·æ‰èƒ½ä¿è¯ updatedAt æ—¶é—´æˆ³æ¯æ¬¡éƒ½æ˜¯æœ€æ–°çš„
    outputs.upToDateWhen { false }
    
	doLast {
		def sourceZip = file("${BUILD_TMP}/docs_full.zip")
		if (!sourceZip.exists()) throw new GradleException("Source zip missing!")

		// [ä¿®å¤] ä½¿ç”¨ String.format æ›¿ä»£ .format() æ–¹æ³•
		def sizeMb = sourceZip.length() / (1024.0 * 1024.0)
		println "ðŸ“¦ Source Zip Size: ${String.format('%.2f', sizeMb)} MB"

		// æ¸…ç†æ—§äº§ç‰©
		if (DIST_DIR.exists()) DIST_DIR.deleteDir()
		DIST_DIR.mkdirs()

		def partsList = []
		def buffer = new byte[CHUNK_SIZE]
		int partIndex = 0
		long totalBytesWritten = 0

		// äºŒè¿›åˆ¶æµåˆ‡åˆ†
		sourceZip.withInputStream { ins ->
			while (true) {
				int bytesRead = ins.read(buffer)
				if (bytesRead <= 0) break

				// å‘½åæ ¼å¼: docs.part000.zip
				String partName = String.format("docs.part%03d.zip", partIndex)
				File partFile = new File(DIST_DIR, partName)

				partFile.withOutputStream { outs ->
					outs.write(buffer, 0, bytesRead)
				}

				// è®¡ç®— MD5
				def md5 = generateMD5(partFile)

				partsList << [
					index: partIndex,
					file: partName,
					md5: md5,
					size: partFile.length()
				]

				// [ä¿®å¤] ä½¿ç”¨ String.format
				def partSizeMb = partFile.length() / (1024.0 * 1024.0)
				println "   -> Generated: ${partName} (${String.format('%.2f', partSizeMb)} MB)"

				partIndex++
				totalBytesWritten += bytesRead
			}
		}

		// ç”Ÿæˆ Manifest
		def manifest = [
			name: "engine_docs.zip",
			totalSize: sourceZip.length(),
			version: rootProject.version,
			// [ä¿®å¤] å¼ºåˆ¶ä½¿ç”¨åŒ—äº¬æ—¶é—´ (Asia/Shanghai)
			updatedAt: new Date().format("yyyy-MM-dd HH:mm:ss", TimeZone.getTimeZone("Asia/Shanghai")),
			parts: partsList
		]

		File jsonFile = new File(DIST_DIR, "docs_manifest.json")
		jsonFile.text = JsonOutput.prettyPrint(JsonOutput.toJson(manifest))

		println "âœ… Build Complete in: ${DIST_DIR}"
		println "ðŸ“œ Manifest created with ${partsList.size()} parts."
		println "ðŸš€ Action: Please Commit & Push 'dist/' folder to GitHub!"
	}
}

// è¾…åŠ©: MD5 è®¡ç®—
def generateMD5(File file) {
	MessageDigest digest = MessageDigest.getInstance("MD5")
	file.withInputStream { is ->
		byte[] buffer = new byte[8192]
		int read
		while ((read = is.read(buffer)) > 0) {
			digest.update(buffer, 0, read)
		}
	}
	return digest.digest().encodeHex().toString()
}
